#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\begin_preamble
\usepackage[T1]{fontenc}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Internal Secrets of Infocom Games"
\pdf_author "Michael Ko"
\pdf_subject "Everything you wanted to know about the internal working of all text-based Infocom games"
\pdf_keywords "Infocom,ZIL"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "pdfnewwindow=true,pdfstartview=XYZ,plainpages=false,colorlinks=true,linkcolor=black,citecolor=black,pdfpagelabels"
\papersize default
\use_geometry true
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 1cm
\bottommargin 2cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0cm
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict true
\html_latex_start <span class='latex'>
\html_latex_end </span>
\end_header

\begin_body

\begin_layout Author
Michael Ko
\end_layout

\begin_layout Title
Internal Secrets of Infocom Games
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://ifsecrets.blogspot.com
\end_layout

\end_inset

 and 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://docs.google.com/document/d/1yNa4M2gN5cG6WoKOSrHtS4_Sp4uwHt1Q7Pvtw8O8hFQ
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subtitle
Everything you wanted to know about the internal working of all text-based
 Infocom games
\end_layout

\begin_layout Date
[2022-09-18]
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section*
\begin_inset VSpace vfill
\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
Decades ago, Infocom was synonymous with good storytelling and creative
 puzzles.
 It wasn’t the first company to release a text interactive fiction game,
 but its first release, Zork I, made it the flagbearer for all other IF
 games to follow.
 Infocom took over the personal computer market for interactive fiction
 games by having their games programmed in ZIL (Zork Implementation Language)
 which is a compact language that easily handled text and object structures.
 ZIL programs were compiled into Z-code, an assembly code that would run
 on a “Z-machine”.
 Infocom created multiple Z-machine emulators (AKA Zork Interpreter Program
 or ZIP) to run on various computers especially home computers like the
 TSR-80, Apple II, and Commodore 64.
 Such an approach allowed a single program to be run on different computers
 without having to create a separate program for each machine.
\end_layout

\begin_layout Standard
Buried in these ZIL programs were the basic structure of how an Infocom
 game is organized and executed.
 And it was Infocom’s parser which could understand complex commands with
 such a small amount of code that seemed miraculous to IF fans.
 The inner workings of Infocom games remained a mystery until reverse engineerin
g was done that decoded the Z-code format.
 Much of the knowledge about Z-code was documented in the Z-Machine Standards
 Document by Graham Nelson and Mark Howell.
 In this, the Z-code instructions and data structure used by some of those
 instructions (like Vocabulary by 
\family typewriter
read
\family default
 or objects by 
\family typewriter
get_prop
\family default
) tables were described.
 As it was a general document, other data structures specific to Infocom
 games like verb syntaxes were not mentioned.
 Several excellent utilities (infodump by Mark Howell and ZILF by Jesse
 McGrew and Josh Lawren) have helped provide more insight on the data structures
 of Infocom games.
 Utilities to translate the Z-code to a more easily readable format did
 help show the inner routines of the games.
 Without variable names, attribute references, and object property names,
 making sense of the game code remained difficult.
 An internal Infocom use only document, “
\emph on
Learning ZIL - or - Everything You Always Wanted to Know About Writing Interacti
ve Fiction But Couldn't Find Anyone Still Working Here to Ask
\emph default
”, gave basic details about the how the games run and how the syntax parts
 of the game were designed in ZIL.
 The release of an MDL-based Zork source code did offer more insight into
 the inner workings of the original Zork game, but understanding MDL was
 an added barrier.
 While there are basic parsing and command processing algorithms in the
 MDL-version of Zork, they were significantly changed when translated to
 the microcomputer versions.
 The release of the 
\series bold
Mini-Zork
\series default
 source code and other tidbits from the Infocom cabinet helped unmask and
 clarify the game code and the coding process that are essential to all
 Infocom games.
\end_layout

\begin_layout Standard
This blog will describe those hidden details of Infocom games, using 
\series bold
Zork 1
\series default
 as the base.
 It will also provide some of the modifications made to these core routines
 by specific Infocom games.
 Subsequent post will provide the inner puzzle workings in all Infocom games.
 Only the text games will be used.
 None of the graphics based games are analyzed.
\end_layout

\begin_layout Standard
All routine and variable names in the Infocom source code (
\series bold
Mini-Zork
\series default
) and documentation are in all capital letters.
 Game names are in bold.
 Unnamed variables and routines are given names that are a best guess.
\end_layout

\begin_layout Standard
Apologizes for any errors in these posts.
 They'll be fixed if possible.
\end_layout

\begin_layout Section
ZIL, ZILCH, ZAP, and ZIP
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
ZIL is a derivative of MDL (MIT Design Language), a LISP-like language,
 with a minimal set of instructions needed to created IF games.
 The Infocom game files created from ZIL source code were run through the
 ZIL compiler (ZILCH) to create Z assembly language code.
 This assembly code was then sent through the Z Assembler Program (ZAP)
 to create the actual Z-code.
 No copies of ZILCH or ZAP software have ever been released or leaked to
 the public.
 There is also very little documentation about these programs.
 The Infocom Cabinet files only mentions some compilation flags used in
 ZILCH and the basic function of ZAP.
 The final Z-code could be run on a “Z-machine” or any computer that emulated
 one using a Zork Interpreter Program (ZIP).
 Different ZIP versions have different memory and processing requirements.
 All have frequently used and writable data in their “core” memory which
 enables quicker execution of the program.
 Less used and read-only data is read from a storage medium (file or disk)
 on an as needed basis.
\end_layout

\begin_layout Standard
Throughout the history of Infocom, six versions of the Z-code were recreated,
 but only the first 5 were used for text-only games.
\end_layout

\begin_layout Subsection
ZIP versions 1
\end_layout

\begin_layout Standard
Many of the Z-code instructions used in Infocom games are in this first
 version of ZIP.
 It is unclear what the memory requirements are for it though.
 Only one ZIP 1 game, 
\series bold
Zork 1
\series default
, was ever released by Infocom.
\end_layout

\begin_layout Subsection
ZIP version 2 
\end_layout

\begin_layout Standard
ZIP 2 was used to create 
\series bold
Zork 1
\series default
-R15 and the first version of Zork 2.
 It introduced frequent words (AKA abbreviations) and a new header element
 (serial number) which is just a 6 digit ASCII representation of the release
 date in year-month-day format.
 
\end_layout

\begin_layout Subsection
ZIP version 3
\end_layout

\begin_layout Standard
Version 3 was used to create a majority of the Infocom games.
 Infocom documents indicates the version 3 compatible ZIP should have a
 minimum of 40K (maybe 32K) of core memory and a floppy drive with at least
 80K of storage.
 Due to limitations to the ZIP 3 format, the maximum size game file is 128K.
 Also the response time should be a few seconds for the average command.
 
\end_layout

\begin_layout Standard
Deadline would be the first new game using this version.
 This version increased the number of abbreviations and added more output
 functions.
 Even after ZIP 4 and 5 were introduced, Infocom would produce 24 games
 using ZIP 3.
\end_layout

\begin_layout Standard
For outputs, ZIP 3 compatible programs had 2 or 3 “windows” where text could
 be displayed instead of 1 in ZIP 1 and 2.
 One of these, the status bar is not usually used unless a special flag
 bit is set in the header.
 Most games create the status bar in the main or lower, window(0).
 Two additional output streams were created.
 One “streams” the text into a specified memory block.
 The other was called a command script which recorded the input and output
 of the game.
\end_layout

\begin_layout Standard
Finally, game verification was added by adding a file length and checksum
 into the header.
 The VERIFY command would check the game data file against these values.
\end_layout

\begin_layout Subsection
Enhanced ZIP (EZIP), version 4
\end_layout

\begin_layout Standard
Version 4, renamed Enhanced ZIP (EZIP), was introduced with 
\series bold
A Mind Forever Voyaging
\series default
.
 A smaller version of EZIP was apparently created called, LZIP, or lower-case
 EZIP for computers with memory limitations.
 The minimal hardware requirements for EZIP were at least 128KB of memory
 and a single disk drive that can at least access 140KB.
 The computer system needs to have upper and lower case characters and a
 screen to display 80 characters across with at least 14 lines.
 These requirements would allow games to only take a few seconds to complete
 a typical “go” command.
 The maximum size game file is 256K.
\end_layout

\begin_layout Standard
EZIP increased the memory space to allow more objects and rooms along with
 longer words (up to 9 characters) in the vocabulary.
 Several new Z-code operands also simplified some of the table-related coding
 for these games, offered more ways to call routines, and gave more control
 to how text displayed on the screen by dividing it up into various windows.
\end_layout

\begin_layout Standard
The specs of EZIP limited these games to an IBM PC, Macintosh, enhanced
 Apple //e, C128, Amiga, and Atari ST.
 Four games were released using this.
 No known LZIP version of games seem to exist.
\end_layout

\begin_layout Subsection
Extended ZIP (XZIP), version 5
\end_layout

\begin_layout Standard
Introduced with Beyond Zork, version 5 (XZIP) allowed for games with more
 objects and rooms and added more opcodes for routine calling, text, and
 table manipulations.
 Borderzone and Sherlock would be the only other new games to use this version.
 Infocom would release its Solid Goal (AKA Greatest Hits) series which were
 re-releases of past popular games but in the XZIP compatible format.
 However these games did not utilize the added functionality of XZIP.
\end_layout

\begin_layout Subsection
YZIP, version 6
\end_layout

\begin_layout Standard
YZIP (successor to XZIP) is version 6 which mainly added mouse, graphical
 windows, and menu functions with Z-codes.
 The graphical based Infocom games used this version and will not be discussed.
\end_layout

\begin_layout Section
General structure of Infocom Games and Data Structures 
\end_layout

\begin_layout Subsection
Introduction and Story Headers
\end_layout

\begin_layout Standard
Since version 1 of ZIP, the story header is a fixed 64 bytes at the start
 of every Infocom game that provides information regarding the location
 of specific data and code.
 The header for ZIP 1 games used the first 9 words/18 bytes.
 Subsequent ZIP versions would add more values into the header.
 XZIP (Version 5) would use all 32 words (64 bytes).
\end_layout

\begin_layout Standard
The original story header information about the game and addresses to specific
 types of data.
 Details are in Appendix A.
 The first word, ZVERSION, ensures that the ZIP is compatible with the given
 story file and emulates the proper Z-machine version.
 The version number is located in the first byte.
 The second byte has the mode flags which are set by the ZAP assembler (for
 bits 0 and 1) and the ZIP at startup for the remaining bits.
 START address will be the first operation to be executed by the ZIP.
 It points to the first instruction and not the start of the routine.
 The next three addresses are used by the various instructions.
 All the object-related operators use the address in OBJECT to manipulate
 the object data.
 The READ instruction uses the Vocabulary data at VOCAB to match and tokenize
 the characters in the input buffer.
 GLOBALS points to the table holding the global variables data.
\end_layout

\begin_layout Standard
ZIP 1 Story Header: 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZVERSION
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 0: Z-machine version 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 1: Z-machine mode
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZORKID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Release number
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ENDLOD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End address of pre-loaded memory, start of variable (or exchangeable memory)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
03
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
START 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address of first instruction (not routine), Program Counter
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
04
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VOCAB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address to Vocabulary table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
05
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OBJECT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address to Object data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
06
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GLOBALS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address to Global Variable table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PURBOT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start address of read-only (static) memory
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
ZIP 1 Story Header
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other information would be added to the story header with newer ZIP versions.
 The complete layout is in Appendix A.
\end_layout

\begin_layout Subsection
The Memory Layout of Infocom Games 
\end_layout

\begin_layout Standard
The layout of data in the Infocom game files is fairly consistent between
 games.
 An example using 
\series bold
Zork 1
\series default
 is shown below.
 The “memory” of the emulated Z-machine is first loaded with the header
 information starting at $0000.
 Memory from $0000 up to PURBOT encompasses the writeable memory such as
 variables, objects, tables, and buffers.
 Data after PURBOT is read-only data such as syntax data, routines, preposition
 data, and strings.
 The exact locations of the syntax data, action routines, and preposition
 table are stored in global variables, not the header.
 The ZIP will continue to load data into memory.
 All data up to the address in ENDLOD must be loaded.
 The ZIP may decide to load data past ENDLOD at its discretion.
 All data after ENDLOD can be swapped out with other disk-based data as
 needed.
 Usually routines and strings are the data that is swapped.
 All important and quickly accessible data remains resident in memory below
 the ENDLOD address.
 A sample layout of data structure in 
\series bold
Zork 1
\series default
 gives more details (using infodump):
\end_layout

\begin_layout Verbatim

Base   End  Size
\end_layout

\begin_layout Verbatim

 0000    3F   40 Story file header
\end_layout

\begin_layout Verbatim

 0040    7D   3D Objects - Property Defaults (Address at OBJECTS, word 5)
\end_layout

\begin_layout Verbatim

 007E   974  935 Objects - Entries
\end_layout

\begin_layout Verbatim

 0975  203A 16C6 Objects - Property data
\end_layout

\begin_layout Verbatim

 203B  221A  1E0 Global Variables (Address at GLOBALS, word 6)
\end_layout

\begin_layout Verbatim

 221B  2C28  A0E Misc Data (such as tables and buffers)
\end_layout

\begin_layout Verbatim

 2C29  2CFE   D6 Syntax - Pointer table (Address at PURBOT)
\end_layout

\begin_layout Verbatim

 2CFF  33d4  6D6 Syntax - Entries (referred by the Pointer Table)
\end_layout

\begin_layout Verbatim

 33D5  34b6   E2 Action routine table (Address in global variables)
\end_layout

\begin_layout Verbatim

 34B7  3598   E2 Pre-action routine table (Address in global variables)
\end_layout

\begin_layout Verbatim

 3599  35DE   46 Preposition table (Address in global variables)
\end_layout

\begin_layout Verbatim

 35DF  46CA 10EC Vocabulary (Address at VOCAB, word 4)
\end_layout

\begin_layout Verbatim

 46CC  EDC5 A6FA Routines (Load up to ENDLOD, $5DEC here)
\end_layout

\begin_layout Verbatim

 EDC6 14328 5563 Strings
\end_layout

\begin_layout Verbatim

14329 143FF   D7 Empty (fill up to the end of memory page)
\end_layout

\begin_layout Subsection
The Massive Object Table
\end_layout

\begin_layout Standard
Objects are the heart of the Infocom games and are the first data after
 the story header.
 Storing them in a logical and efficient manner for the game to access is
 important.
 Each object contains information such as the name, properties and attributes.
 It will also have a parent and possibly siblings.
 The object’s parent is usually a room or container that contains the object.
 Siblings are objects that are in the same room or container.
 Rooms are also considered objects and have a generic ROOMS object as the
 parent for all rooms.
 Attributes are true/false bits that set various characteristics of an object
 such as is it takable (TAKEBIT) or a source of fire (FLAMEBIT).
 They are numbered 0 to 31.
 Each object will define all the attributes.
 Properties are like attributes but hold groups of bytes instead of a bit.
 The maximum size for a property is 8 bytes.
 If no property is given for an object, the default property value (a word)
 is used.
 Properties are numbered 1 to 31.
 Objects are numbered from 1 to 255.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
Default Property Table: 
\end_layout

\begin_deeper
\begin_layout Itemize
31 words that are the default property values if it is not explicit set
 for a specific object
\end_layout

\end_deeper
\begin_layout Itemize
Object Entries - repeated for all objects
\end_layout

\begin_deeper
\begin_layout Itemize
4 bytes representing the 32 attribute bits (#0=top bit of byte 0, #31=bottom
 bit of byte 3) 
\end_layout

\begin_layout Itemize
1 byte each for object number of the parent, sibling, and child of the object
 
\end_layout

\begin_layout Itemize
1 word address to that object’s property table 
\end_layout

\end_deeper
\begin_layout Itemize
Property Table - repeated for all objects with their own property table
 
\end_layout

\begin_deeper
\begin_layout Itemize
1 byte for size of the object name in words 
\end_layout

\begin_layout Itemize
Z-string of the object name 
\end_layout

\begin_layout Itemize
1 byte for property info (LLLNNNNN) 
\end_layout

\begin_deeper
\begin_layout Itemize
bits 5-7 = length of property-1 (length 1-8 bytes is represented as 0-7)
 
\end_layout

\begin_layout Itemize
bits 0-4 = property number 
\end_layout

\end_deeper
\begin_layout Itemize
1-8 bytes of property data 
\end_layout

\begin_layout Itemize
The 1 byte property info and 1-8 property data are repeated for each property,
 listed in descending order
\end_layout

\end_deeper
\begin_layout Standard
Example object property table:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/PropertyTableExample.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Property Table Example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The meaning of an attribute or property number is consistent in all objects
 in that game but not consistent between games.
 For example, the attribute bit and properties used in 
\series bold
Zork 1
\series default
 are listed in Appendices B and C.
 The number of objects is not specifically stored here but calculated based
 upon the number of object entries.
 It can also be calculated by the difference between the addresses of the
 first object entry and first property table entry divided by 9 bytes for
 each entry.
\end_layout

\begin_layout Subsection
Global Variables
\end_layout

\begin_layout Standard
The section following the objects is a 480 byte block corresponding to 240
 global variables with each holding a word.
 By default in Infocom version 1-3 games, variable 0 contains the object
 number of the player’s current location.
 Variable 1 is the score while variable 2 is the number of turns or game
 time.
 A game does not need to use all 240 global variables and can use part of
 this memory block for other variable data such as tables and buffers.
 The addresses to these other data structures as well as addresses to specialize
d grammar structures like syntax entries, preposition table, and action
 routine table are typically stored in global variables.
\end_layout

\begin_layout Subsection
Tables and Buffers
\end_layout

\begin_layout Standard
Between the last global variable and the start of the static data (at PURBOT),
 there is usually extra memory that is used to store custom data structures.
 These are typical tables and buffers.
 Tables are a fixed set of words where the first word (element 0) contains
 the number of elements in the table.
 Examples include tables to hold the direct or indirect object numbers.
 A buffer is just a fixed set of bytes used to hold any type of data.
 The most common buffers used in Infocom games are the input buffer (INBUF)
 or token buffer (LEXV).
 These data structures are not standard to ZIL and are specific to Infocom
 games.
 For ZIP 1-3 games, these tables are located in the preloaded memory of
 the computer.
 For EZIP and XZIP games, tables can also be located amongst the game routines.
 The addresses to these buffers and tables are usually stored in specific
 global variables but can sometimes be hardcoded into the routines that
 use them.
 If a game does not need all 240 global variables, the space for those unused
 variables can be used for buffers and tables.
 Infocom games have their own custom ZIL routines for reading and writing
 to these structures.
 
\end_layout

\begin_layout Subsection
Vocabulary
\end_layout

\begin_layout Standard
The vocabulary contains information about every valid word in the game.
 It begins with a header which contains the information about separator
 characters and the entries themselves.
\end_layout

\begin_layout Itemize
1 byte - N number of separator characters (used to mark the end of words)
\end_layout

\begin_layout Itemize
N bytes - list of N separator characters
\end_layout

\begin_layout Itemize
1 byte - length of each vocabulary entry (Z-string + word type data)
\end_layout

\begin_deeper
\begin_layout Itemize
ZIP 1-3 games: 4 bytes for Z-string
\end_layout

\begin_layout Itemize
EZIP and XZIP games: 6 bytes for Z-string
\end_layout

\begin_layout Itemize
All games use 3 bytes for the word type data except Sherlock (uses 2 bytes)
\end_layout

\end_deeper
\begin_layout Itemize
2 bytes - number of vocabulary entries
\end_layout

\begin_layout Standard
A long list of vocabulary entries will follow this header.
 Each entry starts with a 4 or 6 byte Z-string of the word.
 The remaining 2 or 3 bytes contain:
\end_layout

\begin_layout Itemize
1 byte for word type:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary word type
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Secondary word type
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$00 = Noun
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$02 = Adjective
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adjective
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Special
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$01 = Verb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$03 = Direction
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Itemize
1 byte for second ID value - The secondary ID value if a secondary/non-default
 word type is requested (original format, all games except 
\series bold
Sherlock
\series default
) 
\end_layout

\begin_layout Itemize
1 byte for default ID value - The default ID value 
\end_layout

\begin_layout Standard
ID values are a special number that corresponds to the token such as a verb
 number for a verb.
 For example, the default ID value for a the noun “MATCH” would be its object
 number.
 During word type matching, the default value is returned if there is a
 match.
\end_layout

\begin_layout Standard
If a secondary word type is also given and is a valid word type, then the
 secondary ID value is given.
 If there is no match, then the default one is returned.
 For example, “INFLAT” has its last 3 bytes as [62 a8 d3].
 Bits 7-2 of the word type value $60 indicate this token can be a verb ($40)
 or adjective ($20).
 The last 2 bits ($02 in this example) indicates the secondary word type,
 adjective.
 So the default word type is a verb.
 When the program checks if “INFLAT” is a verb or adjective:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

call wt?(
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

,$40) or <WT? 
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

, PS?VERB>
\end_layout

\begin_layout Plain Layout

call wt?(
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

,$20) or <WT? 
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

, PS?ADJECTIVE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the word type matching routine will return the default, $d3.
 If a second word type ($02) is also passed to the matching routine:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

call wt?(
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

,$40,$02) or <WT? 
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

, PS?VERB, P1?ADJECTIVE>
\end_layout

\begin_layout Plain Layout

call wt?(
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

,$20,$02) or <WT? 
\begin_inset Quotes eld
\end_inset

INFLAT
\begin_inset Quotes erd
\end_inset

, PS?ADJECTIVE, P1?ADJECTIVE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then the routine will return $a8.
 If the second word type does not match, such as $03 (for direction), then
 the default, $d3, will be returned.
\end_layout

\begin_layout Standard
The E/XZIP vocabulary introduced 6 bytes for the Z-string which allowed
 for longer tokens (maximum of 9 characters).
 The size of each entry in Vocabulary grew to 9 bytes.
 A newer compressed vocabulary entry format was also created which used
 a single ID value.
 The need for a second ID value mainly occurred with tokens that can be
 a direction and preposition.
 This format only had 8 byte entries.
 Only 
\series bold
Sherlock
\series default
 used this compressed vocabulary format and had modified syntax routines
 which used the PREP table to look for the this second ID value (preposition
 value) in situations where a token could a direction or preposition.
\end_layout

\begin_layout Subsection
Strings
\end_layout

\begin_layout Standard
Much of the code for Infocom games are the various descriptions and text
 responses that are stored as strings in the special Z-character format.
 It is a compressed format where the characters are represented by 5 bits
 instead of 8.
 This allows 3 letters to be stored in the space of 2 bytes instead of 3.
 More detailed information including the character sets is in the Z-Machine
 Standards Document.
\end_layout

\begin_layout Section
Syntax Entries - The Biggest Mystery of them All
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Probably the most innovative part of Infocom games were their ability to
 understand commands written in conversational English.
 The different types of grammar information were discussed in the “Learning
 ZIL” document.
 The structure of syntax entries in ZIL was shown, but the layout in the
 Z-code files was not mentioned.
 Infodump and ZILF do provide some extra information about the syntax structure.
 There are 3 additional grammar-related data blocks in the game not mentioned
 in the header: prepositions, syntax pointer table, and syntax entries.
\end_layout

\begin_layout Subsection
Prepositions
\end_layout

\begin_layout Standard
There is a separate table of prepositions to speed up the syntax matching
 process.
\end_layout

\begin_layout Itemize
1 byte for number of prepositions
\end_layout

\begin_layout Itemize
2 word entries: address of preposition in vocabulary and preposition number
\end_layout

\begin_layout Standard
The prepositions are numbered from $FF and decrease.
 The address to this table is stored as a global variable.
 EZIP and XZIP use a compact form of the Preposition table that used a byte
 instead of a word for the preposition ID number.
\end_layout

\begin_layout Subsection
Syntax Entry Pointer Table
\end_layout

\begin_layout Standard
The syntax entries are probably the most confusing part of Infocom games
 thanks to the lack of documentation.
 They provide the syntax structure for a particular action.
 To find the matching syntax entry, the verb number is needed.
 Since verbs can have synonyms, different verbs can have the same verb number
 like “GET” and “TAKE”.
 So they would use the same syntax entries.
 The syntax entry table lists the address where the group of syntax entries
 for that specific verb number is located.
 This table is just a block of addresses with verb number $FF is the first
 address.
 Subsequent addresses correspond to smaller verb numbers.
\end_layout

\begin_layout Subsection
Syntax Entries
\end_layout

\begin_layout Standard
PARSER will then look through each of the syntax entries for the matched
 verb number and return the entry that best completely matches the given
 (if any) prepositions and noun clauses types.
 For example, the syntax entry table for verb number $F3 (or GET) has 7
 different syntax entries.
 The syntaxes of “GET object”, “GET object from object”, and “GET on object”
 would correspond to 3 different entries.
 To store this grammatical information, this group of entries start with
 a byte indicating how many entries for that verb.
 It is followed by multiple 8 byte entries for all acceptable grammatical
 combinations:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contents
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of object clauses
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prep number for direct object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prep number for indirect object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT number for direct object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT number for indirect object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte for direct object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte for indirect object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action Number
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Get What I Mean (GWIM) Feature
\end_layout

\begin_layout Standard
The GWIMBIT number is used in the FIND feature mentioned in section 9.5 of
 “Learning ZIL” to find unspecified but necessary objects in a command.
 PARSER will attempt to find an object in the current location with a set
 attribute flag corresponding to the GWIMBIT number.
 If only one object is found to match, it will assume the user meant that
 object and use it in the given command.
 If no object or more than one object matches, PARSER will ask for clarification
 (called orphaning).
 The player can then give a clarifying answer without retyping the entire
 previous command or type a completely new command.
\end_layout

\begin_layout Standard
For example, the syntax entry for “IGNITE OBJ WITH OBJ” has a GWIMBIT number
 for the indirect object set to the FLAME bit.
 If that entry is the best syntax match the command “IGNITE TORCH”, the
 indirect object is still missing.
 PARSER will try to find an object with the FLAME bit set to use as the
 indirect object.
 If a an object in the current location has the FLAME bit set (like a lantern),
 PARSER will assume the indirect object is the lantern.
 The command will then assume to be “IGNITE TORCH WITH LANTERN” and the
 indirect object will be set to LANTERN.
\end_layout

\begin_layout Subsection
Location Restriction of Objects
\end_layout

\begin_layout Standard
The LOC byte is probably the most mysterious value in the syntax entry.
 The highest 7 bits indicate how PARSER searches and checks on requested
 objects.
 For example, PARSER will not complete an action with an object on the ground
 if its syntax entry requires an object be held or carried.
 While “Learning ZIL” has listed 9 possible properties, the source code
 for 
\series bold
Mini-Zork
\series default
 indicates only 7 are used through version 3:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Location-related Flags
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Possession-related Flags
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$02
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$01
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
HELD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
CARRIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
ON-GROUND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
IN-ROOM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
TAKE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
MANY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
HAVE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Not used
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
At top level and not inside another container
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Not at top level, contained inside another object
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
At top level of a room and not inside another container
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Not at top level, contained inside another object on the ground
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Will automatically TAKE object in the current location if necessary before
 using it
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Multiple objects are allowed for a particular action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Must already be in the user’s possession
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
When the GWIM feature tries to search for an unspecified objected, that
 routine needs to know how far to search.
 This is indicated by the flags for HELD, CARRIED, IN-ROOM, and ON-GROUND
 which guide how the function, SEARCH-LIST, finds objects in the given location
 (a room or the user).
 More details will be given in section 13.2.
\end_layout

\begin_layout Standard
“Learning ZIL” does mention an EVERYWHERE and ADJACENT option, but there
 is no evidence that they were ever used in version 1-5 games as confirmed
 by the internal Infocom documents on ZIL.
 It could’ve been used in the graphical YZIP- based games.
\end_layout

\begin_layout Subsection
Pre-actions and Actions
\end_layout

\begin_layout Standard
The action number is used to look up the routine address from the ACTION
 and PRE-ACTION tables.
 These tables sequentially list the packed addresses with any reference
 table.
 All syntaxes that refer to a similar action (INSERT DOWN object, DROP object,
 and SPILL object IN object) will use the same action number.
 INSERT object ON object and INSERT object UNDER object use two different
 action numbers as the game processes these actions differently.
 The action number is also used to lookup the address for the pre-action
 routine if one exists (if not, $0000 is used).
 A pre-action routine can check the objects, variables, or game status before
 a particular action routine is called.
 The same pre-action routine can be used with different action routines.
\end_layout

\begin_layout Subsection
An Example
\end_layout

\begin_layout Standard
Multiple verbs have the same verb number such as CARRY, GET, and TAKE in
 this example.
 The verb number will then correspond a group of syntax entries.
 Here only 3 are used:
\end_layout

\begin_layout Verbatim

[02 00 f0 11 00 64 00 39] "carry OBJ from OBJ"     
\end_layout

\begin_layout Verbatim

[01 f9 00 00 00 00 00 31] "carry out OBJ"     
\end_layout

\begin_layout Verbatim

[01 00 00 11 00 34 00 39] "carry OBJ"
\end_layout

\begin_layout Standard
In the first example, the $02, indicates two noun clauses required for that
 syntax.
 The next two bytes indicate the required prepositions for the noun clauses.
 The $00 indicates no preposition before the direct object clause.
 The $F0 refers to the preposition for the indirect object clause, FROM
 in this case.
 The GWIMBIT number $11 is the attribute to check on objects if the direct
 object is missing.
 There is no GWIMBIT number for the indirect object.
 The direct object LOC byte $64 indicates the direct object should be CARRIED
 or ON-GROUND.
 Also, multiple objects can be in the direct object clause.
 In the second example, the OUT preposition is needed before the direct
 object.
 In the third example, the direct object LOC byte $34 indicates the direct
 object needs to be ON-GROUND or IN-ROOM.
 The last value ($39 or $31) is the action number which indicates what specific
 routine to execute for that command.
 Since the first and third examples are very similar, the same routine will
 be used for both types of commands.
\end_layout

\begin_layout Subsection
Update: Compact Syntaxes to Save Space
\end_layout

\begin_layout Standard
A variable sized syntax entry format was used only with Sherlock to help
 save space.
 There are 3 sizes for the syntax entries based upon the number of noun
 clauses.
 The format is described below.
 The preposition number is stored in the lower 6 bits (after subtracting
 $C0/192 from the preposition number) of bytes 0 and 3.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="8">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10col%">
<column alignment="left" valignment="top" width="20col%">
<column alignment="left" valignment="top" width="9col%">
<column alignment="left" valignment="top" width="9col%">
<column alignment="left" valignment="top" width="9col%">
<column alignment="left" valignment="top" width="9col%">
<column alignment="left" valignment="top" width="9col%">
<column alignment="left" valignment="top" width="9col%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No objects
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
# of objects (high 2 bits) / Prep ID (low 6 bits)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action Number
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Only direct object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
# of objects (high 2 bits) / Prep ID (low 6 bits)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action Number
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- - -
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direct and indirect objects
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
# of objects (high 2 bits) / Prep ID (low 6 bits)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prep ID (low 6 bits)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action Number
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Execution of Infocom Games - An Overview
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
For all of their perceived complexity, Infocom games have a fairly straightforwa
rd and consistent method of getting player commands, parsing them, and executing
 them quickly.
 Each game would start with initial setting of global variables and interrupts.
 This loop starts with PARSER getting a command.
 It will then check and extract all needed grammatical information.
 The game will use PERFORM to call an action on the various objects in that
 command.
 CLOCKER will check and executed any interrupts if necessary.
 Finally, the program repeats this indefinitely or the game stops.
 Each game used the same basic code from initialization of the game through
 handling interrupts.
 The repeated use of previous code help minimize new bugs and kept the play
 of the games consistent.
 But every game had some kind of new code which could introduce bugs.
 The description of these main backbone routines will be from the original
 
\series bold
Zork 1
\series default
 game from 1979.
 Information about updates to these routines will then follow each section.
\end_layout

\begin_layout Subsection
Initialization with GO
\end_layout

\begin_layout Standard
Initialization of each game begins with the GO routine which performs (at
 least) four required tasks:
\end_layout

\begin_layout Itemize
Set important game variables like object number for WINNER or starting location
\end_layout

\begin_layout Itemize
Set any interrupt routines
\end_layout

\begin_layout Itemize
Display the version information of the game
\end_layout

\begin_layout Itemize
Execute the LOOK command for the starting location
\end_layout

\begin_layout Standard
The game then moves to the MAIN-LOOP.
\end_layout

\begin_layout Subsection
Heart Beat of the Game with MAIN-LOOP
\end_layout

\begin_layout Standard
The game will repeatedly get new commands and execute them in an indefinite
 loop, the MAIN-LOOP.
 The commands are obtained and parsed using PARSER which returns the action,
 direct objects, and indirect objects referenced by the given command.
 This loop will then call PERFORM to execute the given action on all the
 direct and indirect objects.
 The turn of the loop will end by calling CLOCKER which executes any necessary
 interrupts.
 MAIN-LOOP will then repeat all of these steps indefinitely.
\end_layout

\begin_layout Subsection
Understanding the User with PARSER
\end_layout

\begin_layout Standard
PARSER takes the player’s input or any remaining input from the last command
 and extracts the parts of command: verb, direct object, and indirect object.
 The part of speech of tokens are identified and later used by CLAUSE to
 find the start and end of object clauses.
\end_layout

\begin_layout Subsection
Completing Previous Command with ORPHAN-MERGE
\end_layout

\begin_layout Standard
If a previous command was orphaned, the given command is examined to by
 ORPHAN-MERGE to see if it supplies the missing information from the orphaned
 command.
 If so, then ORPHAN-MERGE combines the new information with the previous
 command.
 PARSER continues to process this fixed command just like any other command.
\end_layout

\begin_layout Subsection
Match the Command with SYNTAX-CHECK
\end_layout

\begin_layout Standard
The use of syntax templates allowed Infocom games to understand multiple
 commands using similar tokens but in different orders.
 After PARSER identifies the verb, direct object, and indirect object, SYNTAX-CH
ECK will try to match a syntax template to the given verb, prepositions,
 and objects.
 The action with the matched syntax template is returned.
 If the best matched syntax template still has missing objects, the game
 will attempt to supply them with objects in the current location.
\end_layout

\begin_layout Subsection
Find the Objects with SNARF-OBJECT
\end_layout

\begin_layout Standard
After the matching syntax template and objects are verified, the game will
 process each object clause and match the objects with objects from the
 game.
 It will also handle modifiers like EXCEPT and quantities like ALL.
\end_layout

\begin_layout Subsection
Final check on Objects with TAKE-CHECK and MANY-CHECK
\end_layout

\begin_layout Standard
The game will also confirm if the objects need to be taken first (TAKE-CHECK)
 and if multiple objects are allowed for the action (MANY-CHECK).
 Once all the checks are completed, the game creates a table of all the
 objects that are referred in each object clause.
\end_layout

\begin_layout Subsection
Call the Actions with PERFORM
\end_layout

\begin_layout Standard
Finally, the game will execute the requested action (PRSA) on the given
 direct (PRSO) and indirect (PRSI) objects with PERFORM.
 If one noun clause has one object but the other has multiple, the game
 will cycle through the clause with the multiple objects and use the same
 object for the other clause.
 However, if both clauses have multiple objects, only the direct objects
 will be cycled.
 Only the first indirect object will be used.
\end_layout

\begin_layout Subsection
Tick the CLOCKER
\end_layout

\begin_layout Standard
After the player command(s) are performed, the game’s interrupt system “ticks”.
 Any interrupt whose tick count reaches 1 will have its associated routine
 called and then become disabled.
\end_layout

\begin_layout Subsection
Graphic representation of Game Flow
\end_layout

\begin_layout Standard
Routine layout for 
\series bold
Zork 1
\series default
.
 Dotted lines indicate the order of function calls by MAIN-LOOP.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/RoutineLayoutForZork1.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Routine Layout for 
\series bold
Zork 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
GO - Gentlemen, Start Your Engines!
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Return: None
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Every Infocom game begins with an initialization routine, GO, that sets
 certain variables and executes specific routines.
 It will then jump into the MAIN-LOOP which will indefinitely ask for commands
 from the user and process them.
\end_layout

\begin_layout Subsection
Running GO
\end_layout

\begin_layout Standard
All Infocom games have the similar initialization routine for each game.
 “Learning ZIL” mentions that the GO routine should:
\end_layout

\begin_layout Itemize
Set special global variables
\end_layout

\begin_layout Itemize
Set interrupts, usually with the QUEUE or INT routines
\end_layout

\begin_layout Itemize
Display an opening text/title screen
\end_layout

\begin_layout Itemize
Call V-VERSION to show copyright information, release number, and serial
 number
\end_layout

\begin_layout Itemize
Call V-LOOK to describe the current location
\end_layout

\begin_layout Itemize
Call the MAIN-LOOP
\end_layout

\begin_layout Standard
The important global variables that are set include WINNER (object number
 for current active actor which is usually the PLAYER object), HERE (current
 location of the WINNER), and LIT (indicates if the current location is
 lit).
 All version 4 (except AMFV) and 5 games will also check the width of the
 screen.
 Some games will not execute if the screen width is too small.
 Infocom documentation recommends all games start with an opening title
 screen and display game information before showing the current locations
 description.
\end_layout

\begin_layout Section
MAIN-LOOP - Heart of the Game
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Return: None
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
MAIN-LOOP is the heart of all Infocom games and keeps the game structure
 orderly.
 It repeatedly requests for parsed commands and loops indefinitely.
 MAIN-LOOP does not get modified too much with newer games.
 Many of the changes were to make programming game-specific details and
 restrictions easier to do.
 These game changes essentially provided more checks on the player input
 and provided better responses.
 Only significant changes to MAIN-LOOP will be later described.
\end_layout

\begin_layout Subsection
The Details
\end_layout

\begin_layout Standard
MAIN-LOOP will call PARSER to ask and process a user’s command.
 If PARSER cannot properly parse the command, MAIN-LOOP will continue to
 call PARSER to process new commands.
 If it has successfully processed a command, PARSER will set PRSA (parser
 action) with the requested action number (the 8th byte in a syntax entry)
 and fill the PRSO (parser direct object) and PRSI (parser indirect object)
 tables (P-PRSO and P-PRSI) with all the direct and indirect objects requested.
 This is different to what is described in “Learning ZIL”.
 MAIN-LOOP then loops and acts upon all the objects:
\end_layout

\begin_layout Enumerate
Check the number of objects in the direct and indirect clauses
\end_layout

\begin_layout Enumerate
If the direct objects clause has no objects, then see if the action is GO.
\end_layout

\begin_deeper
\begin_layout Enumerate
If so, then call PERFORM with GO and the direction in PRSO.
\end_layout

\begin_layout Enumerate
If no objects are needed for the requested action, then call PERFORM on
 PRSA with no objects
\end_layout

\begin_layout Enumerate
If at least 1 object clause is needed for the requested action, then print
 an error message.
 Display a specific error message if the command is an invalid response
 to an orphaned command.
\end_layout

\end_deeper
\begin_layout Enumerate
One clause will be designated the multiple one and one clause has a constant
 object, first one in the clause.
\end_layout

\begin_layout Enumerate
Call the requested action with PERFORM multiple times for each object in
 the multiple object clause as while the other clause just has its first
 object used.
\end_layout

\begin_deeper
\begin_layout Enumerate
If M-END is returned, then halt the processing of multiple objects.
 Erase any remaining commands.
\end_layout

\begin_layout Enumerate
If M-END is not returned, then continue looping through the multiple objects
\end_layout

\end_deeper
\begin_layout Enumerate
Increase number of turns by 1 (even if multiple object are processed).
\end_layout

\begin_layout Enumerate
Call CLOCKER to check interrupts even if the given command was not valid.
 This was later changed in Deadline and other future games to only calling
 CLOCKER if PARSER was successful.
\end_layout

\begin_layout Subsection
Details of Multiples of Multiples
\end_layout

\begin_layout Standard
The MAIN-LOOP handles commands with multiple objects for a given action.
 It will loop through these objects and execute the same action for each
 object.
 However, there is some confusion as to how it determines preference if
 two sets of objects are given.
 The examples below show how MAIN-LOOP iterates through multiple objects.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="30text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Multiple Direct Objects
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Multiple Indirect Objects
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Multiple Direct and Indirect Objects
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
IGNITE CANDLE AND PAPER WITH TORCH
\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space \qquad{}
\end_inset

IGNITE CANDLE WITH TORCH
\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space \qquad{}
\end_inset

IGNITE PAPER WITH TORCH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
CUT TREE WITH AXE AND SWORD
\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space \qquad{}
\end_inset

CUT TREE WITH AXE
\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space \qquad{}
\end_inset

CUT TREE WITH SWORD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
IGNITE CANDLE AND PAPER WITH TORCH AND FIRE
\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space \qquad{}
\end_inset

IGNITE CANDLE WITH TORCH
\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space \qquad{}
\end_inset

IGNITE PAPER WITH TORCH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
So any additional indirect objects are ignored when there are both multiple
 direct and indirect objects.
 MAIN-LOOP will always iterate through the direct object clause if it has
 the same or more objects than the indirect clause.
 The indirect object remains constant (the first one in the clause) for
 all iterations.
 The only exception is for only 1 direct object and multiple indirect objects.
 MAIN-LOOP will then iterate through the indirect objects while keeping
 the direct object constant.
\end_layout

\begin_layout Subsection
Update: Managing Global Variables
\end_layout

\begin_layout Standard
Only minor improvements were made with handling the PRSA, PRSO, and PRSI
 variables.
 Updating the L- versions of these variables which are used by the AGAIN
 command was moved into the MAIN-LOOP section starting with 
\series bold
Zork 2
\series default
.
 Later games would excluding updating these variables if certain commands
 were used.
 
\series bold
Zork 3
\series default
 added the option of checking the the LIT variable with commands that require
 no objects.
 If it was clear, then a “It’s too dark to see” error would be given.
 
\series bold
Zork 2
\series default
 (R28) also moved the updating of the IT-OBJECT and its location variable
 into the MAIN-LOOP instead of PERFORM.
 
\series bold
LGOP
\series default
 and 
\series bold
Plundered Hearts
\series default
 also added a specific check on the visibility of the IT-OBJECT in the MAIN-LOOP.
\end_layout

\begin_layout Subsection
Update: How many NOT-HERE-OBJECTs?
\end_layout

\begin_layout Standard
To generate a better user responses when some objects are missing in a command,
 MAIN-LOOP (since 
\series bold
Infidel
\series default
) started to count how many requested objects in a multiple object command
 were not present.
 This number was kept in the global P-NOT-HERE variable and used to provide
 a more specific error message for missing objects.
 For example, if more than P-NOT-HERE was greater than 1, the error message
 would use “objects” instead of “object”.
 One final coding relic is the P-MULT flag.
 It is cleared and set in the MAIN-LOOP, but has been used only in 
\series bold
Infidel
\series default
’s NOT-HERE-OBJECT ACTION routine.
 All subsequent ZIP 3 games since 
\series bold
Infidel
\series default
 still set this flag, but it is never used.
 It is also present in various developmental versions but not used.
 Its true function remains unclear.
\end_layout

\begin_layout Subsection
Update: Checking For Invalid Exceptions
\end_layout

\begin_layout Standard
Starting with 
\series bold
Deadline
\series default
, MAIN-LOOP would check for specific invalid situation where an action should
 not be done on a specific object.
 
\series bold
Deadline
\series default
 ensured that none of the referred objects in a command was the WINNER.
 
\series bold
Planetfall
\series default
 had its own special check on objects used with “PICK UP” by making sure
 the PRSO was on/in PRSI.
 If not, it would skip over that PRSO.
\end_layout

\begin_layout Standard

\series bold
Wishbringer
\series default
 (R69) would be the first game to check for these exceptions in a separate
 routine instead of in MAIN-LOOP.
 It would be called whenever the GETFLAG mode in the game is set to ALL.
 MAIN-LOOP will iterate through each object in a multiple object clause
 and check it for any invalid exceptions exits before sending it off to
 PERFORM.
 If an invalid exception exists, PERFORM will be skipped.
 This CheckException routine usually looks for the actions that require
 the object be held or local such as DROP or INSERT.
 If that command is being used, the routine will see if the proper attributes
 are set (TAKEN, for example), held by the WINNER, or not already inserted
 for example.
 Every game since 
\series bold
Wishbringer
\series default
 has such a routine.
\end_layout

\begin_layout Section
PARSER: How Now Brown Cow
\end_layout

\begin_layout Subsection*
(Part 1) - Data Structures
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Result: TRUE if command is valid, FALSE if command is not valid
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Probably the most intrigue feature of Infocom games has always been the
 parser.
 The minimal online documentation touched only on the features of PARSER
 but never the mechanism behind PARSER.
 Since 
\series bold
Zork 1
\series default
, the general approach to parsing has been relatively unchanged with successive
 Infocom games.
 Improvements were made, but they mainly expanded the syntaxes that the
 game would understand.
 Many games have special commands or ways to interact with the PLAYER that
 results in modifications in PARSER.
 Finally, the first EZIP game, 
\series bold
AMFV
\series default
, added new parser commands like OOPS.
\end_layout

\begin_layout Subsection
Characters vs.
 Tokens
\end_layout

\begin_layout Standard
The ZIP language's READ routine will take a sequence of characters and store
 it in the input buffer (INBUF).
 The first byte in that buffer has the number of characters in the input.
 The input ends with a zero byte and does not include the terminating character
 like a carriage return.
 READ will then match words in the input buffer to those in the game’s vocabular
y and create a separate buffer of values corresponding to the matched words
 (called tokenizing).
 Words are separated by a space or designated separator characters stored
 in the vocabulary.
 For each word, a 4 byte block is created from three pieces of information
 for each token.
 First, the Z-string of the word is created and matched to the words in
 the vocabulary.
 All ZIP 1 to 3 games were limited to the first six characters of a word.
 ZIP 4 and 5 could use up to nine characters.
 If a match is found, the address of that word in the vocabulary table is
 saved in the first two bytes of the block.
 If no match is found, 0 is used.
 The third byte in the block will be the length of the token.
 The last byte is the offset from the start of the input buffer.
 The token buffer (LEXV) starts with two bytes.
 The first byte in the token buffer is the maximum number of tokens allowed.
 The second byte is the actual number of tokens in the buffer.
 The rest of the token buffer are groups of 4 byte token data blocks to
 represent the words in the input.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/InbufAndLEXV.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
INBUF and LEXV
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
PARSER Variables and Grammatical Structure Definitions
\end_layout

\begin_layout Standard
In “The Parser’s Role” section of “Learning ZIL”, PARSER takes the input
 and tries to identify the action number for PRSA and the object numbers
 for PRSO (parser direct object) and PRSI (parser indirect object).
 This is not quite correct.
 It will set PRSA with the action referred by the verb in the input.
 However, PARSER does not set PRSO or PRSI.
 The only exception is if the PRSA is GO.
 Then the PRSO is set to the exit direction.
 The routine actually fills two tables (P-PRSO and P-PRSI) with all the
 direct and indirect objects requested in the command.
\end_layout

\begin_layout Standard
The basic grammar structure for a command is:
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

verb + prep + noun clause + prep + noun clause + end-of-command +
\end_layout

\begin_layout Plain Layout

verb + prep + noun clause + prep + noun clause + end-of-command ...
\end_layout

\end_inset

Only the verb is required.
 All other parts are optional.
 A noun clause is a noun or set of nouns connected by conjunctions (AND
 or commas).
 These nouns can be modified by adjectives, quantifiers (ALL, A, or ONE),
 or other special tokens excluding prepositions (OF, BUT, or EXCEPT).
 The entire noun clause is referred as a direct or indirect object clause.
 Prepositions are not included in the noun clause.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

For example:
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

DROP THE YELLOW BALL AND CROWBAR
\end_layout

\begin_layout Plain Layout

INSERT A DOLLAR INTO THE RED SLOT 
\end_layout

\begin_layout Plain Layout

TAKE ALL EXCEPT THE CANDLES
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
THE YELLOW BALL AND CROWBAR
\family default
, 
\family typewriter
A DOLLAR, THE RED SLOT
\family default
, and 
\family typewriter
ALL EXCEPT THE CANDLES
\family default
 are the noun clauses.
\end_layout

\begin_layout Standard
Individual commands can be connected together with end-of-command tokens
 (THEN, AND,
\family typewriter
 ,
\family default
 or periods) that indicate where a command stops.
 So:
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

DROP THE YELLOW BALL AND TAKE THE CROWBAR
\end_layout

\begin_layout Plain Layout

DROP THE YELLOW BALL.
 TAKE THE CROWBAR
\end_layout

\end_inset

are equivalent to
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

DROP THE YELLOW BALL THEN TAKE THE CROWBAR
\end_layout

\end_inset

Commas can separate multiple objects in a single noun clause or indicate
 the start of a new command.
 So:
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

DROP THE BALL, A RAKE AND SHOVEL
\end_layout

\begin_layout Plain Layout

DROP THE BALL, TAKE THE SHOVEL
\end_layout

\end_inset

are processed differently based upon word type after the comma.
 More in the details below.
\end_layout

\begin_layout Subsection
PARSER Table (ITBL)
\end_layout

\begin_layout Standard
The main goal of PARSER is to extract the action (PRSA) and valid objects
 in the direct and indirect object clauses from the given command.
 To assist other routines in extracting this information, PARSER will store
 specific information related to the verb, prepositions, and location of
 noun clauses in a 10 word table, ITBL:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verb Number (VERB)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verb Table Address (VERBN)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prep Number (PREP1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Addr of Prep (PREP1N)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prep Number (PREP2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Addr of Prep (PREP2N)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start Addr of Direct Clause (NC1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End Addr of Direct Clause (NC1L)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start Addr of Indirect Clause (NC2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End Addr of Indirect Clause (NC2L)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

The verb number is a unique value for similar meaning verbs in the vocabulary.
 It is not the same as the action number.
 A verb will have the same verb number no matter the context of its use
 but it could have a different action number.
 For example, LOOK has the verb number $E9 in all syntaxes, but the action
 number for LOOK FOR is $2D, LOOK IN is $3F, and LOOK is $D0 corresponding
 to different types of actions.
 The verb table contains the same information about the verb as in the token
 buffer: verb’s address (in Vocabulary), length, and location in the input
 buffer (INBUF).
 The start and end addresses of a clause refer to locations in the token
 buffer (LEXV).
 Of note, this end address actually points to the token AFTER the last included
 token in the particular clause.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/ParserTableLEXV.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Parser Table
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Checking Word Types with WT?
\end_layout

\begin_layout Description
Arguments (Address, word type to match, word type to return)
\end_layout

\begin_layout Description
Return ID value or FALSE if no match
\end_layout

\begin_layout Standard
WT? is one of the most important routines in Infocom games and sees if the
 Vocabulary entry at the given address has the given word type.
 This is the primary word type as described in Section 2.6.
 If the primary word type does not match the given word type, WT? returns
 with FALSE.
 If there is a match, the result returned depends on the third argument.
 If no third argument is given, the routine will return TRUE.
 If the third argument matches the secondary word type (as described in
 Section 2.6), then the secondary ID is returned.
 Otherwise, the primary ID is returned regardless if it is a valid word
 type for the primary ID.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<column alignment="center" valignment="top" width="10col%">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary word type
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Secondary word type
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$02 = Adjective
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$00 = Noun
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adjective
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Special
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$03 = Direction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$01 = Verb
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Using:
\end_layout

\begin_layout Verbatim

$4386:3A 6B C4 D9 62 B5 B4
\end_layout

\begin_layout Standard
the first 4 bytes are the z-string for “inflat”.
 $62 indicates it is an verb and adjective.
 So,
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
CALL WT?($4386, $40 or $20)
\family default
 will return TRUE
\end_layout

\begin_layout Standard

\family typewriter
CALL WT?($4386, $40 or $20, $02)
\family default
 will return the secondary ID of $B5.
\end_layout

\begin_layout Standard

\family typewriter
CALL WT?($4386, $40 or $20, $00 or $01 or $03)
\family default
 will return the primary ID of $B4.
\end_layout

\begin_layout Standard

\family typewriter
CALL WT?($4386, $10)
\family default
 will return FALSE as there is no match.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Infocom games interestingly do not put the special ID values for directions,
 verbs, or adjectives as the primary ID value when those tokens only have
 one word type.
 For example, the Vocabulary entry for “search” is:
\end_layout

\begin_layout Verbatim

$4967:61 46 DD 0D 41 E0 00
\end_layout

\begin_layout Standard
with the word type as 41 (primary type is verb, secondary type is verb).
 The primary ID value is $00 though.
 To get the verb number ($E0), you have to access the secondary ID by using
 $03 as the third argument:
\end_layout

\begin_layout Verbatim

CALL WT?($4967, $40, $01)
\end_layout

\begin_layout Standard
Since a third argument is needed anyways to get an ID value, the designers
 to just put it as the secondary ID value.
\end_layout

\begin_layout Standard
Almost everyone game uses the same WT? routine.
 So games did not even use a separate routine but just hard coded the check
 when needed.
 
\series bold
LGOP
\series default
 did add an additional word type check for nouns, $80.
 If it was found, the routine would quickly exit (no value is returned for
 nouns) and bypass checking for secondary word types.
 
\series bold
Sherlock
\series default
 uses the newer compressed Vocabulary entry format.
 Since secondary word type checking happened mainly with prepositions, WT?
 only allowed prepositions to be checked then when secondary word type arguments
 are given.
 This is done by searching the Preposition table.
 If a match is found the preposition value is calculated based upon the
 token’s position in the Preposition table.
 Internal Infocom notes mentions a special WT? for 
\series bold
The Lurking Horror
\series default
 where 3 ID values were stored for each token, but no evidence of this can
 be found of this routine in the 3 known game releases.
\end_layout

\begin_layout Subsection*
(Part 2) - Scanning Tokens
\end_layout

\begin_layout Subsection
Start of PARSER: Where is the command? 
\end_layout

\begin_layout Standard
PARSER was able to understand single commands or multiple commands separated
 by “.” or THEN by parsing them individually.
 It first decides if the next command should come from the previously given
 input by seeing if P-CONT is set.
 This variable contains the starting location of the next command’s first
 token from the previous input.
 This is set by seeing if more tokens exist after a complete command is
 parsed.
 If P-CONT is clear, PARSER then asks for new input from the user by printing
 “>” character and calling the READ opcode.
\end_layout

\begin_layout Subsection
Now, Traverse the Tokens…
\end_layout

\begin_layout Standard
Because of the structure of accepted commands, PARSER can search for a command
 in an efficient manner.
 It will walk through the tokens and look for ones with specific parts of
 speech.
 If a noun clause is found, PARSER will call another routine, CLAUSE, to
 find the start and end tokens for the direct object clause.
 If no error is returned by CLAUSE, PARSER will continue checking tokens
 and look for another noun clause (indirect object clause) or end-of-command
 token.
 The order for checking tokens is:
\end_layout

\begin_layout Enumerate
Invalid Token
\begin_inset Newline newline
\end_inset

All valid tokens have an address to their associated entry in the vocabulary.
 Any invalid or unmatch tokens are given an address of $00.
 If this is found, an unknown-word error message will be printed and FALSE
 returned.
\end_layout

\begin_layout Enumerate
End-of-Command Token
\begin_inset Newline newline
\end_inset

An end-of-command token (THEN or “.”) will stop the loop and jump to the
 post-looping processing.
 If there are more tokens, PARSER will save the position of this next token
 which PARSER will use for the next command.
\end_layout

\begin_layout Enumerate
Direction Token
\begin_inset Newline newline
\end_inset

This is the only verb with its own specific check in PARSER since it is
 the most common command given.
 A direction token has an associated direction value which is the property
 number for a room’s exits in that direction.
 There are 4 special scenarios where this direction value is saved and the
 loop is stopped:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

1.
 This is a 1 token command, just the direction is given.
\begin_inset Newline newline
\end_inset

2.
 This is a 2 token command and the verb GO was already given (as in “GO
 EAST”).
\begin_inset Newline newline
\end_inset

3.
 There are more tokens after the direction, and the next token is a end-of-comma
nd token.
\begin_inset Newline newline
\end_inset

4.
 There are more tokens after the direction, and the next token is a conjunction
 token (AND or “,”).
 If so, the conjunction token is changed to “then” to indicate a new command.
 So a series of direction commands separated by commas or “and” become separate
 commands.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

PRSA is set to GO (if not already done).
 PRSO is later set to the direction value.
 
\end_layout

\begin_layout Enumerate
Verb Token
\begin_inset Newline newline
\end_inset

If a verb token is found, PARSER checks if a verb has already been a found.
 A command cannot have two verbs.
 If no verb has already been found, this verb’s verb number and address
 to a verb table that has the 4 byte token data are stored in words 0 and
 1 of ITBL.
 If a verb has already be found, PARSER will see if it the word could also
 refer to a different valid part of speech.
\end_layout

\begin_layout Enumerate
Preposition, Quantity, Adjective, and Noun Tokens
\begin_inset Newline newline
\end_inset

Any of the above tokens indicates a noun clause is starting.
 The number of noun clauses variable is incremented.
 A separate routine (CLAUSE) will then find the end of the noun clause and
 store the start and end addresses in ITBL.
 CLAUSE then returns the start address of any remaining tokens PARSER should
 process.
 There are several exceptions where CLAUSE is not execute:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

1.
 If the matched adjective or noun is followed by OF, PARSER will ignore
 the adjective and noun and use the token after OF for the start of the
 noun clause.
 This new token will be matched on a subsequent loop.
\begin_inset Newline newline
\end_inset

2.
 If there are no more tokens or an end-of-command token is next after the
 matched preposition and less than 2 noun clauses have been found, the prepositi
on address and value information will be save into ITBL (Word 2 and 3).
\begin_inset Newline newline
\end_inset

3.
 If there are already 2 noun clauses, a "Too many noun clauses??" error
 is given.
 PARSER will then return with FALSE.
\end_layout

\begin_layout Enumerate
Special Token
\begin_inset Newline newline
\end_inset

Any remaining special tokens that do not affect the syntax or objects requested
 will be ignored.
 This includes tokens like IS, YES, A, or THE.
\end_layout

\begin_layout Enumerate
Improper/extra tokens - Syntax Error
\begin_inset Newline newline
\end_inset

All other situations are a syntax error.
 Therefore, PARSER will display a can’t-use-the-word error and return FALSE.
 examples?
\end_layout

\begin_layout Standard
The first version of PARSER could understand multiple commands if they were
 separated by THEN or “.”.
 Using AND or “,” between verbs without objects like
\end_layout

\begin_layout Verbatim

JUMP AND LOOK
\end_layout

\begin_layout Standard
were not understood.
 However, commands with objects separated by AND or “,” like
\end_layout

\begin_layout Verbatim

OPEN MAILBOX AND GET LEAFLET
\end_layout

\begin_layout Standard
are accepted as CLAUSE would realize the AND separates two commands.
\end_layout

\begin_layout Subsection*
(Part 3) - Updates (Actors, Adverbs, and Numbers) 
\end_layout

\begin_layout Subsection
Update: Speaking to Actors with Quotes
\end_layout

\begin_layout Standard
The first modification to PARSER began with 
\series bold
Zork 2
\series default
 and relates to double quotes in commands.
 A double quote is treated like an end-of-command token like THEN or period.
 It also toggles the QUOTE-FLAG which is essentially a flag for finding
 an another double quote.
 The first double quote seen sets that flag.
 A second will clear it.
\end_layout

\begin_layout Standard
In 
\series bold
Zork 2
\series default
, the use of a double quote comes into play in several special situations.When
 the player says something out loud such as SAY “ABRACADABRA”, the game
 will typically ignore these commands unless you are saying special words
 for a spell or a riddle.
 The game will then pull out the word after the first double quote and use
 it to trigger other routines.
\end_layout

\begin_layout Standard
PARSER will also handle speaking to the other actors using quotes.
 Actors are characters in the game that can be asked questions or perform
 actions.
 They are created using objects and have the PERSONBIT set.
 Using interrupts, the game can have the actors move or perform other actions
 on their own.
 To have an actor perform an action like:
\end_layout

\begin_layout Verbatim

TELL WIZARD 
\begin_inset Quotes eld
\end_inset

TURN OFF THE LAMP
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
PARSER first divides up the command into two separate commands with the
 double quote as the terminating token for both commands.
 So the previous command becomes:
\end_layout

\begin_layout Standard

\begin_inset VSpace defskip
\end_inset


\family typewriter
TELL WIZARD
\begin_inset Quotes erd
\end_inset


\family default
 and
\end_layout

\begin_layout Standard

\family typewriter
TURN OFF THE LAMP
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
To have actors perform actions, PERFORM (discussed later) will call the
 TELL/ASK routine first which ensure the direct object is a person (PERSONBIT)
 and then set WINNER to the actor.
 PARSER will then process the second command with the actor as the WINNER.
 The individual action routines handle these special situation where actors
 perform the commands by checking the value of WINNER.
 Later, PARSER will ensure that WINNER is set back to the player on its
 next execution by detecting a clear QUOTE-FLAG and WINNER not set to the
 player.
 
\end_layout

\begin_layout Standard

\series bold
Deadline
\series default
 expanded the methods for interacting with actors by allowing commands in
 these formats:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
TELL/ASK 
\shape slanted
actor
\shape default
 TO 
\shape slanted
command
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
Actor
\shape default
 THEN 
\shape slanted
command
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
PARSER would change the TO or THEN tokens to a double quote token which
 is then treated as an end-of-command token just like it was back in 
\series bold
Zork 2
\series default
.
 The verb number in ITBL would automatically be set to the verb number for
 TELL if the second format is used.
 
\series bold
HGTG
\series default
 later added a check to ensure the token after TO was a verb which indicated
 the start of another command.
\end_layout

\begin_layout Standard
The player in 
\series bold
Deadline
\series default
 could also refer to actors with their name followed by a comma:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
Actor, command
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
PARSER (through CLAUSE) considers as a end-of-command between two commands.
 The comma is then changed to “then” and processed like in the other formats.
\end_layout

\begin_layout Standard
Deadline also allowed the PLAYER to ask the actors directly about an object
 or ask them to give you an object using:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
ASK 
\shape slanted
actor
\shape default
 ABOUT 
\shape slanted
object
\end_layout

\begin_layout Standard

\family typewriter
ASK 
\shape slanted
actor
\shape default
 FOR 
\shape slanted
object
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
These are treated like any other command and depend on the object attributes.
\end_layout

\begin_layout Standard
Finally, 
\series bold
Deadline
\series default
 also introduced a new routine which checks if the requested actor is in
 the current location and if the subsequent command is appropriate (action
 is WHAT, FIND, TELL, or SHOW) before allowing the commands to be processed.
 This check would be added to subsequent games.
\end_layout

\begin_layout Standard
PERFORM will call the TELL/ASK routine which ensure the direct object is
 a person (PERSONBIT) and then set WINNER to the actor.
 PARSER will then process the second command with the actor as the WINNER.
\end_layout

\begin_layout Subsection
Update: Titles and Adverbs (briefly)
\end_layout

\begin_layout Standard
The recognition of titles used to address actors like MRS.
 or MR.
 and automatically skip them along with any following period was introduced
 with 
\series bold
Deadline
\series default
.
 The game also recognized 5 specific adverbs (CAREFULLY, QUIETLY, SLOWLY,
 QUICKLY, and BRIEFLY) and saved the adverb’s Vocabulary address in ADVERB.
 It would be used later by specific action routines such as WATCH, GO, or
 READ.
 The adverbs were considered a special token and not a specific part of
 speech.
 
\series bold
Bureaucracy
\series default
 is the only game with adverbs, but they are not needed to complete the
 game.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Update: Numbers, a new object
\end_layout

\begin_layout Standard
Deadline introduce numbers and time to Infocom games.
 Since these values do not match with any token, they are given a $0000
 Vocabulary address.
 NUMBER? will then change the $0000 to the vocabulary address for a “intnum”
 or “number” token.
 A special global variable contains the numerical value.
 For time values, the time in minutes is saved:
\end_layout

\begin_layout Enumerate
Loop through all the characters of an unknown token
\end_layout

\begin_layout Enumerate
If the character is a digit, then take the current sum, multiply it by 10,
 and add this value of this digit.
\end_layout

\begin_layout Enumerate
If a “:” is found, then the previous digits are likely an hour value.
 Save this into a separate TIM variable and reset the total sum.
 Continue looping through the remaining digits which will be the minutes
 value.
\end_layout

\begin_layout Enumerate
Once all the digits are read (and there are no extra non-digit characters),
 then the sum (value of the digits) is save into P-NUMBER and this unknown
 token is given the Vocabulary address for “intnum”.
\end_layout

\begin_layout Enumerate
If the sum is greater than 10000, then the routine will return FALSE.
\end_layout

\begin_layout Enumerate
If the number was an time value, then the sum is actually the minutes value.
 The routine will take the hour value and multiply it by 60 and then add
 the sum.
 If the hour value is greater than 23, then the routine will return FALSE.
 There is no restriction on the size of the minutes value though.
 This new sum (time in minutes) is also saved in P-NUMBER.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/NumbersAndTime.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Numbers, Time
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Routines can then search for the “intnum” token and use the value in the
 corresponding global variable.
 Because of this design, only one number or time value could be used in
 each command.
 Games using time values can impose certain restrictions on the what hours
 are valid.
 For example, 
\series bold
Deadline
\series default
 considers any time between 1:00 and 7:59 to be PM.
 So 7:00 is converted to 19:00 (or 7pm) for the game.
 Hours from 0 to 23 are considered valid for all games.
 Most games will convert the hour and minutes into all minutes.
 Only 
\series bold
Sherlock
\series default
 checks the value of the minutes.
 So a time value of 14:80 could be valid in most games that use time as
 they are converted to all minutes.
\end_layout

\begin_layout Standard
More number formats would be recognized in later games.
 They are listed below:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="25text%">
<column alignment="left" valignment="top" width="25text%">
<column alignment="left" valignment="top" width="40text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Added Format
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Game Introduced
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$xxx
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cutthroats
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No cents portion is allowed.
 The value is saved in a different global variable than P-NUMBER.
 The “intnum” object has it’s property 11 set to “amount of money”.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xxx-yyyy
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Suspect
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The phone number is stored as two separate numbers in separate global variables
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xxx,xxx
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LGOP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comma separated number is converted to a single 4-6 digit number
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xx(B-E) $xxx.yy #xxxx
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bureaucracy
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number followed by letters B-E indicates seat row and letter (4 times row
 # + seat letter converted to 0-3 value) and money value (converted to cents)
 are saved in their own special global values.
 The object type returned is “intnum” except for a money value where “money”
 is used.
 If a # starts a number, it is ignored.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HH:MM AM/PM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sherlock
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The hour is converted to the corresponding 24 hour value.
 The entire time is saved in the game’s special time table format
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
PARSER: New Commands and Routines
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Ever since the first version of 
\series bold
Zork 1
\series default
, there has been an AGAIN command.
 However, it basically used the previously saved PRSA, PRSO, and PRSI in
 a PERFORM call.
 The use of EZIP allowed new routines to be created to handle the various
 new buffers and provide new commands.
 Starting with 
\series bold
AMFV
\series default
, a new method to manage the input and token buffers allowed for a more
 sophisticated AGAIN command.
 The game also introduced the OOPS command where unknown words in a command
 could be corrected one by one.
 
\series bold
Beyond Zork
\series default
 added the UNDO command which allows the user to “go back” one command.
\end_layout

\begin_layout Standard
Also two new buffers were created, AGAIN-LEXV and OOPS-INBUF, for three
 new routines.
 In essence, they could be also considered previous LEXV and previous INBUF,
 respectively.
\end_layout

\begin_layout Subsection
STUFF
\end_layout

\begin_layout Description
Arguments: source buffer, destination buffer, length
\end_layout

\begin_layout Description
Returns: TRUE
\end_layout

\begin_layout Standard
STUFF copies a set length of tokens from the source buffer to the destination
 buffer.
 If no length is given, the maximum length (29 tokens) is used.
 First, the two bytes (maximum and actual number of tokens) at the start
 of the token buffer are copied.
 Then all the token buffer data is copied up to the amount requested.
 The routine always returns TRUE.
 
\series bold
Beyond Zork
\series default
 was able to replace this routine with a new opcode (COPY_TABLE).
 
\series bold
Sherlock
\series default
 still used STUFF.
\end_layout

\begin_layout Subsection
INBUF-STUFF
\end_layout

\begin_layout Description
Arguments: source buffer, destination buffer
\end_layout

\begin_layout Description
Returns: TRUE
\end_layout

\begin_layout Standard
INBUF-STUFF just copies the entire contents one character at at time of
 the source input buffer to the destination input buffer.
 With XZIP, 
\series bold
Beyond Zork
\series default
 and 
\series bold
Sherlock
\series default
 used a new instruction (COPY_TABLE) to handle this routines.
\end_layout

\begin_layout Subsection
New AGAIN command
\end_layout

\begin_layout Standard
In Infocom games since 
\series bold
AMFV
\series default
, the AGAIN command is more formally processed and checked specifically
 by PARSER.
 If it is given, several checks are done before the old command is copied
 back and processed:
\end_layout

\begin_layout Itemize
Check that last command was not orphaned
\end_layout

\begin_layout Itemize
Check that last command was valid
\end_layout

\begin_layout Itemize
Check that the actor in last command is still present.
 This is to ensure that any non-player actor is present if an actor direct
 command is used again.
\end_layout

\begin_layout Itemize
Check the subsequent token (if it exists) is not a end-of-command token
 (THEN, AND.
 period, or comma).
 Then print the error message.
\end_layout

\begin_layout Standard
If all the above checks pass, PARSER copies the old input buffer from OOPS-INBUF
 into INBUF.
 It does the same for the AGAIN-LEXV to LEXV.
\end_layout

\begin_layout Standard
If commands exist after an AGAIN command, the entire token and input buffers
 are temporarily saved into reserve buffers, RESERVE-LEXV and RESERVE-INBUF,
 respectively, because they would’ve been overwritten while performing the
 AGAIN command.
 The start of the next command is also saved in RESERVE-PTR.
 The previous WINNER, P-MERGED flag, and DIR (just in case) are restored
 from global variables.
 The previous token and input buffers, AGAIN-LEXV and OOPS-INBUF, are again
 copied back into LEXV and INBUF, respectively.
 Finally, OTBL is copied back into ITBL.
 PARSER then continues to process the newly restored command as normal.
 On the next iteration of PARSER, it will detect that RESERVE-PTR is set
 and copy the remain command info from RESERVE-LEXV and RESERVE-INBUF data
 back into LEXV and INBUF, respectively.
 The next command starts in the restored data at the location indicated
 by RESERVE-PTR.
\end_layout

\begin_layout Subsection
OOPS!
\end_layout

\begin_layout Standard
The OOPS command was an important innovation in the era before copy and
 paste were invented.
 Previously any commands with errors would have to be completely re-typed
 with the correction.
 This was especially painful for long or multiple commands.
 The user could correct any errors with
\end_layout

\begin_layout Verbatim

OOPS <replacement token>
\end_layout

\begin_layout Standard
If an unknown token is found, various values are calculated and stored in
 OOPS-TABLE:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset to unknown token in AGAIN-LEXV
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset to start of command with unknown token in AGAIN-LEXV
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length of all token data in command with the unknown token
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset to byte after the end of OOPS-INBUF
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

PARSER will grab the Vocabulary address of the replacement token (after
 OOPS) and replace it with the empty address in the unknown token’s entry
 in AGAIN-LEXV.
 Only the first token after OOPS is checked.
 An error message is display if more tokens are given.
 INBUF-ADD is called to appended the replacement token to the end of the
 OOPS-INBUF.
 That routine will also store the replacement token’s length and updated
 pointer in OOPS-INBUF in the unknown token’s entry in AGAIN-LEXV.
 Finally the modified OOPS-INBUF and AGAIN-LEXV are copied back into the
 INBUF and LEXV, respectively.
 PARSER then resumes parsing the command as it normally does.
 If there is another unknown word error in this just correct command, another
 OOPS can be used to correct the next error.
 This can go on until all the errors are fixed.
\end_layout

\begin_layout Standard
This feature has been present in all version 3 games since 
\series bold
Sorcerer
\series default
-R18, and all version 4 and 5 games since its introduction.
\end_layout

\begin_layout Subsection
INBUF-ADD
\end_layout

\begin_layout Description
Arguments: length of replacement token, ptr of replacement token in INBUF,
 offset of unknown token in OOPS-INBUF
\end_layout

\begin_layout Description
Returns: TRUE
\end_layout

\begin_layout Standard
INBUF-ADD is slightly more sophisticated.
 The characters for the referred token in the first two arguments in appended
 to the end of OOPS-INBUF.
 The pointer to the end of OOPS-INBUF is retrieved from the OOPS-TABLE (or
 calculated using the data from the last token if it is not in the OOPS-TABLE).
 The length of this replacement token and pointer to it in OOPS-INBUF are
 copied back into the unknown token’s entry in AGAIN-LEXV.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/InbufAdd.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
INBUF-ADD and OOPS-TABLE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
UNDO
\end_layout

\begin_layout Standard
Finally an UNDO command was introduced with 
\series bold
Beyond Zork
\series default
 which would restore the game state before the last command was executed.
 While this capability was available since version 1 of Z-machines, it was
 never implemented because of the need for more internal memory (a limited
 quantity back then) or having to constantly save the data onto an external
 memory storage device, likely a disk drive, which would slow the execution
 of the game down.
 But the requirements of XZIP called for ZIP emulators with higher memory
 capacities, the necessary game state data could be saved into a different
 part of the internal memory.
 Only 
\series bold
Beyond Zork
\series default
 and 
\series bold
Sherlock
\series default
 had this function.
\end_layout

\begin_layout Standard
The saving of the current game state was done in the PARSER routine after
 the check for a GO command.
 The save_undo operation is used to copy the contents of dynamic memory
 (everything before the Syntax data) which is essentially the header information
, all OBJECT data, global variables, tables, and buffers.
 Also the call stack is saved.
 If the player uses the UNDO command, it would call a separate routine that
 would attempt to restore the saved gate state data and continue with the
 execution of the command after the save_undo operation in PARSER.
 If an error occurs, the appropriate error message is displayed.
\end_layout

\begin_layout Subsection
Update: Other Minor Changes in PARSER
\end_layout

\begin_layout Standard
EZIP and XZIP games only added slight modifications to PARSER.
 Most of these revolved around setting or clearing certain global variables
 such as XNAM.
 Others would search for unimportant tokens such as “please” and skip over
 them.
\end_layout

\begin_layout Subsection
Update: ReplaceToken routine
\end_layout

\begin_layout Standard
With the advent of the AGAIN command in AMFV and its use of the AGAIN-LEXV
 buffer, the replacing of tokens in PARSER and CLAUSE required changes in
 both those buffers.
 So a new routine was created, ReplaceToken.
 But it also including a way to copy the length and pointer information
 for the token before the replaced one into the location of the replaced
 one.
 The dictionary address for the replaced token will then be modified as
 normal.
\end_layout

\begin_layout Section
CLAUSE: Find the Noun Clause Boundaries
\end_layout

\begin_layout Description
Arguments: Start address of clause, Preposition number of clause, Vocabulary
 address of current token
\end_layout

\begin_layout Description
Return: Address to start of clause, -1 if no tokens are left to process,
 or FALSE if error in clause syntax
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
CLAUSE will find the end address of a noun clause and saves the start and
 end addresses for this clause along with the preposition information in
 ITBL.
 P-NCN (noun clause number) indicates if the direct (1) or indirect (2)
 object clause is being processed.
 Specific locations in ITBL for the extracted information to be stored are
 calculated depending on P-NCN.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="40text%">
<column alignment="center" valignment="top" width="25text%">
<column alignment="center" valignment="top" width="25text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direct Object (Noun 1) Clause
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Indirect Object (Noun 2) Clause
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preposition Number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vocabulary Address of Preposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address of First Token (Start)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address after Last Token (End)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
How it screens...
\end_layout

\begin_layout Standard
CLAUSE loops through tokens in LEXV as long as the given tokens are part
 of a valid syntax for a noun clause.
 Briefly, the routine will
\end_layout

\begin_layout Itemize
Save any preposition information (number and address) if it exists into
 the proper locations in ITBL.
\end_layout

\begin_deeper
\begin_layout Itemize
The preposition information is usually passed as an argument.
 CLAUSE will then find the Vocabulary address of the preposition.
\end_layout

\begin_layout Itemize
If no preposition is given or exists, $00 is saved as the preposition number
 and address
\end_layout

\end_deeper
\begin_layout Itemize
Save the start address of the noun clause into the proper location in ITBL.
\end_layout

\begin_layout Itemize
Attempt to get the next token to process as well.
\end_layout

\begin_layout Itemize
Loop through the tokens in LEXV as long as the given tokens are part of
 a valid syntax for a noun clause (see rules below)
\end_layout

\begin_layout Standard
Once the routine stopped checking for tokens, it can return three possible
 results: FALSE if there was a syntax error, -1 if no more tokens left to
 process, or offset to the last token in the newly found clause.
 The address after the end of the newly found clause will be saved in the
 proper location in ITBL for the end address of the clause.
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="30text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unmatched
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Display error & return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Conjunction (“and” or “,”)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eat apple 
\series bold
and
\series default
 orange
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set ANDFLAG & continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quantity (“all” or “one”)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Take all
\series default
 bananas
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quantity (“all” or “one”) + “of”
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Burn one of
\series default
 the letters
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Skip “of” token & continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End-of-command “then” or “.”
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Throw hammer 
\series bold
then
\series default
 go west
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Save end address of current noun clause and return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preposition (not the first token in the clause)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Put letter 
\series bold
inside
\series default
 mailbox
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Save end address of current noun clause and return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun (also an Adjective) + Noun
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Drop 
\series bold
gold coin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun and ANDFLAG set
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eat apple and 
\series bold
orange
\series default
 and grape
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Clear ANDFLAG & continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun and ANDFLAG clear and next token is an exception (“but” or “exception”)
 or conjunction token
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eat 
\series bold
apple
\series default
 and orange 
\begin_inset Newline newline
\end_inset

Eat all 
\series bold
fruit
\series default
 except banana
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Turn 
\series bold
statue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Save end address of current noun clause & return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adjective
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read 
\series bold
brown
\series default
 book
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Special (not Conjunction, Quantity, or End-of-command)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Push 
\series bold
the
\series default
 button
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All others (verbs or direction) and ANDFLAG set
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ignite red match and 
\series bold
go
\series default
 east
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change conjunction token to “then” and go back 2 tokens to process again*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All others (verbs or direction) and ANDFLAG clear
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cut rope 
\series bold
go
\series default
 north
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Display “Can’t Use” error & return
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align left
*For example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},showstringspaces=false,tabsize=1"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

get candle and eat apple
\end_layout

\begin_layout Plain Layout
\noindent
\align left

             ^
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
is converted to:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},showstringspaces=false,tabsize=1"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

get candle then eat apple
\end_layout

\begin_layout Plain Layout
\noindent
\align left

         ^
\end_layout

\end_inset


\end_layout

\begin_layout Standard
with CLAUSE going back to the conjunction token to reprocess the clause.
 The routine will recognize “then” as an end-of-command token, marking the
 end of a clause.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Subsection
Update: New Matches…
\end_layout

\begin_layout Standard
Later Infocom games added more acceptable token combination for clauses
 which caused CLAUSE to also grow.
 Outside of specialized tokens used in specific games (such as spell names
 in Spellbreaker), the new and improved CLAUSE mainly became more sophisticated
 on deciding what part of speech a token was being based upon its context
 with other tokens.
 The major additional rules created by Infocom are below:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="25text%">
<column alignment="left" valignment="top" width="25text%">
<column alignment="left" valignment="top" width="25text%">
<column alignment="left" valignment="top" width="15text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Game
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Articles ("the","a","an")
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eat 
\series bold
an
\series default
 apple
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Skip over token & continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deadline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unmatched and NUMBER? is true
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Take 2 candles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unmatched token changed to “intnum”, global var set to value, & continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deadline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
“of” and verb = “accuse”
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accuse Bob 
\series bold
of
\series default
 murder
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change “of” to “with” & continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deadline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
“.” and previous token is a title (“mrs”,”mr”,”ms”, “dr”, “st”)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ask Mr.
 Smith about paper
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deadline, LGOP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preposition (first token checked)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Throw 
\series bold
out
\series default
 ball
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zork 1-R88
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preposition (prep value already given in argument)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Skip over token & continue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LGOP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preposition (can also be an adjective) and a prep has already been give
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write on 
\series bold
back
\series default
 side
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assume preposition is an adjective and continue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bureaucracy
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun (can also be adjective) and next token is noun or adj or direction
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Drop 
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
gold
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 coin
\begin_inset Newline newline
\end_inset

Take 
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
copper
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 hot rod
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assume noun is an adjective & Continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HGTG, Moonmist
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adjective AND P-MERGED/ P-OFLAG set or verb given
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Green
\series default

\begin_inset Newline newline
\end_inset

Get 
\series bold
Green
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zork 1-R88
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Special (not Conjunction, Quantity, or End-of-command) AND P-MERGED/ P-OFLAG
 set or verb given
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\series default
 red
\begin_inset Newline newline
\end_inset

Get 
\series bold
a
\series default
 red
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zork 1-R88
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All others (verb, direction) and ANDFLAG set and verb given
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ignite red match and 
\series bold
go
\series default
 east
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change conjunction token to “then” and go back 2 tokens & continue
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Seastalker
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Profanity, interrogatives
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eat banana 
\series bold
who
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Display error message & stop
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LGOP, Trinity
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
ORPHAN-MERGE: Fix What Is Broken
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Return: TRUE if orphaned command is corrected, FALSE if unable to correct
 the orphaned command
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Now that the major parts of the command have been identified (if they exist)
 and stored in ITBL, PARSER will first see if the given command corrects
 an orphaned command, a previous command that had ambiguous or missing necessary
 information.
 Originally, only nouns could be ambiguous.
 So the clarifying token had be an adjective.
 If an adjective could refer to more than one object in a location, an error
 was given.
\end_layout

\begin_layout Standard
For example, the user enters:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

IGNITE CANDLE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in an empty room.
 An orphaned command will be created as no indirect object is given (the
 candle needs to be ignited with something).
 The game will respond that it does not know what the user wants to ignite
 the touch with.
 This could be correct by then typing:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

TORCH
\end_layout

\end_inset

 or 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

WITH THE TORCH
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A new command IGNITE CANDLE WITH TORCH would be created and replace the
 previous command TORCH (or WITH THE TORCH) and then processed by PARSER.
\end_layout

\begin_layout Standard
In another example, a room contains a red card, red flower, and blue flower.
 If the command was
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

GET FLOWER
\end_layout

\end_inset


\end_layout

\begin_layout Standard
it would be considered ambiguous as it could be the red or blue flower.
 This could be corrected by typing:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

RED
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which would then lead to a newly created command:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

GET RED FLOWER
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the command was
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

GET BLUE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
GET-OBJECT which matches the token with an object would be able to figure
 out you meant the blue flower as there is only one object with the BLUE
 adjective.
 If the command was
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

GET RED
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then GET-OBJECT would display a missing noun error as the game will not
 create an orphaned command from an ambiguous adjective.
\end_layout

\begin_layout Standard
Starting with 
\series bold
HGTG
\series default
, ambiguous adjectives could be used to create an orphaned command be later
 clarified with a noun.
 So the previous example would prompt the game to ask you for clarification
 on which RED object.
 These examples could be corrected by typing just CARD or FLOWER.
 So a clarifying noun could also refer to more than one object in the same
 room which would then trigger another orphan command.
 The game would then use the new information to match a single specific
 object and process the newly completed command.
\end_layout

\begin_layout Subsection
Fixing Orphans with ORPHAN-MERGE
\end_layout

\begin_layout Standard
ORPHAN-MERGE is called by PARSER if the P-OFLAG has been set in 2 possible
 situations:
\end_layout

\begin_layout Itemize
SYNTAX-CHECK is in unable to match even one syntax entries for the given
 verb because of a missing object clause
\end_layout

\begin_layout Itemize
GET-OBJECT is matches more than one object for the given noun, adjective,
 or GWIM bit
\end_layout

\begin_layout Standard
Regardless of the outcome of the routine call, P-OFLAG will be cleared.
 So the user only has one chance to supply missing or clarifying tokens
 to an orphaned command.
 The orphaned command data is stored in OTBL (a mirror of ITBL) and OCLAUSE
 (a mirror of LEXV).
\end_layout

\begin_layout Standard
ORPHAN-MERGE first validates the given input through various checks.
 Only the missing or clarifying token is required.
 If any extra information is given (like prepositions or verbs) are given,
 then they must match the ones in the orphaned command to be accepted.
 ORPHAN-MERGE checks two aspects of the given input:
\end_layout

\begin_layout Itemize
Verb - To be a valid response to an orphan command, the new input must have
 the same verb as the orphaned command or must have no verb.
 If the verb is different, the new input is likely a new command, and ORPHAN-MER
GE will return with FALSE.
\end_layout

\begin_layout Itemize
Number of noun clause - Only one noun clause is allowed to clarify an ambiguous
 or supply a missing noun clause.
 If two are given in the new input, then ORPHAN-MERGE will return with FALSE.
\end_layout

\begin_layout Standard
ORPHAN-MERGE then checks if the orphaned command has a missing clause by
 looking for $01 in the starting address of the noun clauses in OTBL.
 If both object clauses have starting addresses equal to $01, then only
 the direct object clause is processed.
 PARSER will then attempt to process this partially completed command and
 again discover this partially incomplete command can satisfy a syntax entry.
 If this new command is again unable to be matched with a syntax, it will
 be orphaned with the indirect object clause missing, The user can then
 input another clarifying command for the indirect object clause.
\end_layout

\begin_layout Standard
Once a missing object clause is found, ORPHAN-MERGE will see ensure that
 the preposition in the given input (if entered) matches the one in the
 orphaned command (stored in OTBL).
 Finally, the routine will copy the start and end addresses of the clarifying
 noun clause (the single adjective) from LEXV into the appropriate start
 and end address in OTBL.
 If the missing object clause is the indirect one, the number of noun clauses
 will also be set to 2.
 ORPHAN-MERGE will then skip checking if the given input clarifies an ambiguous
 noun.
\end_layout

\begin_layout Subsection
Clearing up Ambiguity
\end_layout

\begin_layout Standard
If no missing noun clause found in OTBL (start address with $01), the given
 input could clarify an ambiguous noun.
 ORPHAN-MERGE checks if P-ACLAUSE was set (by GET-OBJECTS) to the element
 of the clause’s start address in OTBL with the ambiguous noun ($06 for
 direct object and $08 for indirect object clause).
 ORPHAN-MERGE will then proceed:
\end_layout

\begin_layout Itemize
Check that there is only one noun clause in the given input.
 If there are more, than clear P-ACLAUSE and return with a FALSE.
\end_layout

\begin_layout Itemize
Loop through the tokens in the noun clause indicated by P-ACLAUSE and check
 their word types.
\end_layout

\begin_layout Itemize
If the token’s word type is an adjective, then temporarily save the vocabulary
 address of that token.
 If an adjective has already been found, the new one will override the old
 one.
 So only the last given adjective is used for clarification.
\end_layout

\begin_layout Itemize
If the token’s word type is a noun, then ORPHAN-MERGE ensures that the token
 is the same as the ambiguous noun (P-NAM) or is “ONE”.
 In the above example, “BLUE ONE” or “RED FLOWER” are both valid for the
 ambiguous FLOWER.
 It will then stop checking tokens and call ACLAUSE-WIN (to create a new
 noun clause)
\end_layout

\begin_layout Itemize
All other word types or mismatched nouns will cause ORPHAN-MERGE to stop
 checking tokens and return FALSE.
\end_layout

\begin_layout Itemize
If no nouns are given after checking all the tokens in the given noun clause,
 ORPHAN-MERGE will also call ACLAUSE-WIN using the last found adjective
 in the given noun clause.
\end_layout

\begin_layout Itemize
If no adjective is given after checking all those tokens, ORPHAN-MERGE will
 return false.
\end_layout

\begin_layout Standard
Once any missing noun clause is replaced or an ambiguous word is clarified,
 ORPHAN-MERGE will copy the data from OTBL into ITBL for PARSER to continue
 to processing as if the complete command had just been entered.
 So an clarified orphaned command will use tokens located in LEXV and OCLAUSE.
\end_layout

\begin_layout Subsection
ACLAUSE-WIN
\end_layout

\begin_layout Description
Arguments: Vocabulary address for Adjective
\end_layout

\begin_layout Description
Return: TRUE
\end_layout

\begin_layout Standard
ACLAUSE-WIN setups up parameters for CLAUSE-COPY using ACLAUSE (element
 number of a clause’s start address such as $06), ACLAUSE + 1 (element number
 of clause’s end address such as $07), and the clarifying adjective.
 By setting the parse table that CLAUSE-COPY should use (CC-TBL) to OTBL,
 CLAUSE-COPY will copy the tokens from OCLAUSE back to OCLAUSE and insert
 a clarifying adjective before the ambiguous noun (P-NAM).
 The routine will also ensure the P-NCN is set to the correct number of
 noun clauses.
 ACLAUSE is cleared to indicate the ambiguous noun was clarified.
\end_layout

\begin_layout Subsection
Using CLAUSE-COPY
\end_layout

\begin_layout Description
Arguments: Element number of start address of clause in ITBL, Element number
 of end address of clause in ITBL, INSERT adjective (optional)
\end_layout

\begin_layout Description
Return: TRUE
\end_layout

\begin_layout Standard
CLAUSE-COPY copies tokens from LEXV to the end of OCLAUSE using the addresses
 in one of the parse table (ITBL or OTBL) referred by a global variable
 (official name is not known).
 CLAUSE-COPY is called with two arguments, the element numbers that identify
 the start and end addresses for the noun clause to copy.
 These element values are $06 and $07 for the direct object clause or $08
 and $09 for the indirect object clause.
 It will then append the requested tokens to the end of OCLAUSE.
\end_layout

\begin_layout Itemize
Find the offset to the end of OCLAUSE using the value in element 0.
\end_layout

\begin_layout Itemize
Calculate the new start address of the orphaned noun clause by finding the
 end address of OCLAUSE as it is the start address for the newly appended
 tokens.
\end_layout

\begin_layout Itemize
Store this new start address in the appropriate element (start address for
 DO or IO clause) in OTBL ($06 or $08).
\end_layout

\begin_layout Itemize
CLAUSE-COPY will repeatedly call CLAUSE-ADD to copy the tokens located in
 the requested noun clause to the end of OCLAUSE.
 These new tokens have their byte pointer to the input buffer and length
 set to zero.
\end_layout

\begin_layout Itemize
If a clarifying token (usually an adjective) is given while copying these
 tokens, CLAUSE-COPY will check if the copied token matches the current
 ambiguous token, P-ANAM (a vocabulary address for the ambiguous noun).
 If a match is found, CLAUSE-ADD is called with the vocabulary address of
 ths clarifying token and a new token with the clarifying token is added
 to OCLAUSE.
 Then the P-ANAM is also added to OCLAUSE with CLAUSE-ADD.
\end_layout

\begin_layout Itemize
Once all the remaining tokens in the requested noun clause are appended
 to OCLAUSE, CLAUSE-COPY will calculate the new end address of OCLAUSE and
 save it into the proper element (end address of noun clause) in OTBL.
\end_layout

\begin_layout Standard
Starting with 
\series bold
Zork 1
\series default
, there was a bug with this setup.
 Each time an orphaned noun clause was created, it was appended to OCLAUSE.
 Since the end of OCLAUSE was never reset back to $00, it was possible OCLAUSE
 would grow outside of its 100 byte size limit and spill over into the memory
 locations of other variables.
 This was correct with 
\series bold
Zork 3
\series default
 by setting the size of OCLAUSE to zero in the OPRHAN routine.
\end_layout

\begin_layout Subsection
CLAUSE-ADD
\end_layout

\begin_layout Description
Arguments: Vocabulary address to token
\end_layout

\begin_layout Description
Return: True
\end_layout

\begin_layout Standard
CLAUSE-ADD takes the given Vocabulary address and creates a new token add
 the end of OCLAUSE.
 Originally, the destination token buffer defaulted to OCLAUSE.
 In 
\series bold
Moonmist
\series default
, the P-CCTBL was used to stored the address of the destination token buffer
 in element 2.
 More information about P-CCTBL in Section 10.10.
 In 
\series bold
Bureaucracy
\series default
 (and later 
\series bold
Beyond Zork
\series default
), the address of the destination token buffer was passed as the 2nd argument
 instead of using P-CCTBL.
\end_layout

\begin_layout Subsection
Update: New changes of ORPHAN-MERGE
\end_layout

\begin_layout Standard
First changes to ORPHAN-MERGE were with 
\series bold
Zork 1-R88
\series default
.
 It mainly corrected the bug when a first token in a claifying response
 which can be a verb and an adjective is matched as a verb first.
 This is especially an issue when only the first 6 characters are used.
 For example, the command:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

BOARD BOAT
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in a location with a row boat and inflatable boat in created an orphaned
 command because BOAT is ambiguous.
 If the user then enters:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

INFLAT
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the original ORPHAN-MERGE processes INFLAT as “inflate”, the verb, and asks
 what object to inflate.
 However, then this new version will understand that the user meant an “inflatab
le” BOAT and treat INFLAT as an adjective to clarify the ambiguous BOAT.
 Also, ORPHAN-MERGE will understand that the input:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

INFLAT BOAT
\end_layout

\end_inset


\end_layout

\begin_layout Standard
means INFLAT is the adjective “inflatable” because the next token, BOAT,
 is a noun.
 INFLAT will then clarify the ambiguous noun.
 Obviously, any token that can be a verb and adjective will be treated as
 a verb by PARSER if there no orphan command to clarify.
 “ALL” and “ONE” are also considered valid adjectives for the purpose of
 clarification.
 Finally, a new global variable, P-MERGED, is set if an orphaned command
 is clarified and is used mainly when printing object names in PRSO/PRSI-PRINT
 to ensure the whole correct object name is printed and not the clarifying
 token.
\end_layout

\begin_layout Standard

\series bold
Planetfall-R37
\series default
 introduced a similar dual word type option for tokens which can be verbs
 and nouns.
 Early in the routine, the given verb was checked for this dual word type.
 If it could be a noun, then ORPHAN-MERGE assumed it should be treated as
 a noun.
 The start address of the subsequent noun clause was adjusted to include
 the previously thought verb.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

IGNITE TORCH
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which will result in a missing noun error (need an indirect object).
 If the user then types:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

FIRE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
this token can be a verb or noun.
 but will be treated as a noun as there is an orphaned command.
\end_layout

\begin_layout Standard

\series bold
HGTG
\series default
 introduced the ability to clarify an ambiguous adjective.
 In those situations, a clarifying noun is given.
 Previously, any noun given in the clarifying clause is ignored (if it is
 the same one in the orphaned command) or causes an error if its different.
 Now, ORPHAN-MERGE will also look for a clarifying noun if the ambiguous
 word is an adjective.
 NCLAUSE-WIN is called to complete the clarification.
 ONE and ALL are valid adjectives or nouns and can clarify either ambiguous
 nouns or adjectives.
 If either of these tokens follows another adjective, then they should be
 considered a noun and call ACLAUSE-WIN immediately with the given adjective
 as the clarifying token.
 Finally, there is a new data structure, OVTBL, which holds the VTBL from
 original command that was orphaned.
 Essentially, ORPHAN-MERGE copies back the information from OVTBL into VTBL
 but sets OTBL’s VTBL addr to VTBL and not OVTBL.
 But the OTBL information will be copied back to ITBL.
\end_layout

\begin_layout Standard
Suspect reconfirmed the number of noun clauses in the fixed orphan command
 by seeing if the OTBL”s IO’s start address is set.
 If also skipped out of ORPHAN-MERGE if it was called while there are still
 unprocessed commands are given where the next verb is “tell”.
\end_layout

\begin_layout Standard

\series bold
AMFV
\series default
 changed the checking of a given verb.
 If it is the same as the orphaned command, then skip over checking it as
 a possible an adj.
 If the given verb does not match, then ORPHAN-MERGE will check to see if
 that token can also be an adj.
\end_layout

\begin_layout Standard

\series bold
Bureaucracy
\series default
 did not include the NCLAUSE-WIN option but did allow for the entire noun
 clause to be used to clarify the ambiguous noun.
 This is done by setting the ADJ to $01 which will cause CLAUSE-COPY to
 insert the entire noun clause instead of just the adjective.
 It also blocks certain adjectives for clarifications.
\end_layout

\begin_layout Standard

\series bold
The Lurking Horror
\series default
 introduced the assumption that if a verb is given without a noun clause,
 then the verb could be the clarifying token.
 The start of the noun clause would then be adjusted to include the verb
 token.
 Copying of OVTBL and OTBL is gone???
\end_layout

\begin_layout Standard

\series bold
Sherlock
\series default
 did also check to see if a solo verb can be a noun.
 If so, then the verb table is cleared and the start and end addresses of
 the DO are set to include the verb token.
 Sherlock will adjusted the end address of the DO clause to include the
 entire IO clause for certain situations (<name> + TOMB or BOX + <adj/noun>).
\end_layout

\begin_layout Standard

\series bold
AMFV
\series default
 changed the way that the clarifying input is used with orphaned commands.
 The main new feature is clarifying an ambiguous noun as well.
 ORPHAN-MERGE still begins with
\end_layout

\begin_layout Itemize
Check if the new input’s verb (if given) matches the one in the orphaned
 command or the given verb also can be an adjective.
 If so, set the ADJ to $01 for now.
\end_layout

\begin_layout Itemize
Otherwise check if the given verb can also be a noun.
 If so and no other nouns were given then set the start and end addresses
 of the direct object clause to be those around the first token (address
 of the first token and address of the second token).
 The verb # and addr to VTBl will be cleared.
\end_layout

\begin_layout Standard
After those possible scenarios are checked, the routine does the similar
 checking as the first gen ORPHAN-MERGE.
 It first checks the scenarios where a verb is given which could have different
 meanings.
\end_layout

\begin_layout Itemize
If the new verb is different than the old verb from OTBL, then return false.
 The new input is probably a new command.
\end_layout

\begin_layout Itemize
If the new verb can also be an adjective, then save it in ADJ just in case.
\end_layout

\begin_layout Itemize
If the new verb can also be a noun and no noun clauses are given, then set
 the start and end addresses of the direct object clause to point to the
 verb.
\end_layout

\begin_layout Standard
The routine then does a few more checks:
\end_layout

\begin_layout Itemize
Rechecks the verb in the new input (if it exists).
 If this new verb is not the same as the one in the OTBL and it cannot also
 be an adjective, then RFALSE (an error).
\end_layout

\begin_layout Itemize
If there two noun clauses are given, then it is an error (can’t offer two
 answers to correct an orphaned command).
\end_layout

\begin_layout Standard
The first type of orphan correction is replacing a missing noun clause.
 This is marked by $01 as the start address of a noun clause.
 The routine will check the direct object clause first and then the indirect
 object clause if the direct object is not missing any information.
 The routine cannot correct both clauses with a single command.
\end_layout

\begin_layout Itemize
Check that the preposition in the new input (if given) is the same as the
 one in the orphaned noun clause.
 If it is not the same, then return false.
\end_layout

\begin_layout Itemize
If ADJ is set (which means the verb is can also be a clarifying adjective),
 then set the start and end addresses of the missing noun clause in OTBL
 to address of the first token in the token buffer.
 If the ADJ is not set, then set the start and end addresses of the missing
 noun clause in OTBL to the ones from the direct object clause in ITBL.
 For a missing indirect object clause, the routine copies the start and
 end addresses from the direct object clause in ITBL to the indirect object
 clause in OTBL and sets the # of noun clauses to 2.
\end_layout

\begin_layout Standard
If neither noun clause is missing, the routine will look for a clause with
 an ambiguous token.
 In that situation, ACLAUSE has the field # for the clause with the ambiguous
 token whose vocabulary address is in P-ANAM.
 The routine will make sure there is only 1 noun clause to clarify the ambiguous
 token.
 If is no noun clauses given and any verb in the new input cannot be an
 adjective as well, then it will error.
 The routine will then walk through the tokens in the direct object clause
 of the new input to find the appropriate clarifying tokens for the orphaned
 command.
 Each token will be checked:
\end_layout

\begin_layout Itemize
A quantity token (ALL, EVERYT, ONE) - set current token as ADJ
\end_layout

\begin_layout Itemize
An adjective type - set cur token as ADJ
\end_layout

\begin_layout Itemize
ONE (after other tokens) - call ACLAUSE-WIN with ADJ and stop looping
\end_layout

\begin_layout Itemize
A noun type - If it is the same as the ambiguous token, then call ACLAUSE-WIN
 with ADJ.
 Otherwise, call NCLAUSE-WIN as the noun is a clarifying token.
\end_layout

\begin_layout Standard
If END is blank (for some reason), then set # of noun clause to 1, set END
 to original BEG, and set BEG to 1 token block before END.
 Once all the checking has been done, ORPHAN-MERGE will copy the info from
 OVTBL back to VTBL and copy the OTBL info back to ITBL.
 P-MERGED is then set to indicate the orphan command is probably fixed.
\end_layout

\begin_layout Subsection
Update: New ACLAUSE-WIN expands its options
\end_layout

\begin_layout Standard

\series bold
Zork 1-R88
\series default
 also began to use the OVTBL to hold the corresponding verb info for the
 ambiguous noun.
 This would be used to later repopulate VTBL and create a valid command
 with the clarified token and ambiguous noun.
\end_layout

\begin_layout Standard

\series bold
HGTG
\series default
 began to use the CC-TBL to hold parameters needed for ACLAUSE-WIN.
 Theses were mainly the source and destination buffer.
 This allowed other buffers besides OCLAUSE to be used.
 The dictionary address of the clarifying adjective in INSRT was still the
 only passed argument.
\end_layout

\begin_layout Standard

\series bold
AMFV
\series default
 abandoned using CC-TBL because all of the needed values could be passed
 as routine arguments.
\end_layout

\begin_layout Standard

\series bold
Bureaucracy
\series default
 added an interesting twist if ACLAUSE-WIN was called with a blank INSRT.
 In that situation, it is set to $01 which then causes CLAUSE-COPY to insert
 the entire direct object clause of the recently entered clarifying command
 instead of a single token.
 Lurking Horror got rid of this function.
\end_layout

\begin_layout Subsection
Update: NCLAUSE-WIN
\end_layout

\begin_layout Description
Arguments: Nothing
\end_layout

\begin_layout Description
Results: True
\end_layout

\begin_layout Standard
NCLAUSE-WIN is a new routine first used in HGTG that is used when players
 were able to clarify an ambiguous adjective.
 It was not always allowed after its introduction in HGTG.
 It always uses the direct object clause from ITBL as the source (obviously
 as the clarifying noun is the first any only object given in an input)
 and P-ACLAUSE as the destination clause in OTBL.
 It also adjusts the number of noun clauses if necessary.
 Since Trinity, newer version 4 games and all version 5 games that did allow
 for ambiguous nouns used a version that did not rely on CC-TBL to pass
 arguments to CLAUSE-COPY.
 This could be done with the routine call arguments now.
\end_layout

\begin_layout Standard
This new version adds several more checks:
\end_layout

\begin_layout Standard
if there are no noun clauses and the given verb can be an noun, then assume
 the verb is a noun actually and create a noun clause around it.
 Also adjust the NCN to 1.
 It can then continue processing it.
\end_layout

\begin_layout Standard
It also looks for “one” when checking for nouns.
 Typically, “one” is usually an adjective.
 But if it follows after another adjective, then it should be considered
 a noun and call ACLAUSE-WIN immediately.
\end_layout

\begin_layout Subsection
Update: New version of CLAUSE-COPY
\end_layout

\begin_layout Standard
With 
\series bold
HGTG
\series default
, the destination addresses were added to P-CCTBL in those situations where
 CLAUSE-COPY was need to copy tokens to something other than OCLAUSE.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Element # for start address for source token buffer
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Element # for end address in source token buffer
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Element # for start address in destination token buffer
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Element # for end address in destination token buffer
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Also the tables with source and destination addresses were passed to CLAUSE-COPY
 along with the clarifying adjective to insert.
 
\end_layout

\begin_layout Standard

\series bold
LGOP
\series default
 checked to see if the first token to add to the OCLAUSE is the same as
 the clarifying token.
 If so, then don’t check to see if current token to copy is the ambiguous
 one.
 Just copy it to OCLAUSE.
 
\series bold
LGOP
\series default
 also fixed the resetting of OCLAUSE ptrs by moving all the recently added
 tokens to OCLAUSE to the front of OCLAUSE.
\end_layout

\begin_layout Standard

\series bold
Moonmist
\series default
 added more changes.
 First, it changed the parameters in CCTBL to the address of the destination
 token buffer (such as OCLAUSE) in word 2.
 No word 3 value is needed.
 Second, it also checked the first token in the destination token buffer
 was the same as the clarifying token when the ambiguous token is found
 while copying tokens.
 If so, it would skip over adding this clarifying token but would add the
 ambiguous token to the destination token.
 Finally, if the INSRT=$01, it would copy the entire direct object clause
 in the clarifying command before the ambiguous token.
 This allows a phrase to be copied instead of a signal token.
\end_layout

\begin_layout Standard

\series bold
Bureaucracy
\series default
 did not have rely on CC-TBL for arguments as it was written in ZIP 4 which
 allowed up to 7 arguments to be passed to routines.
 CLAUSE-COPY past the address to the source and destination input tables,
 elements for the start and end addresses for the tokens to copy, source
 of the tokens, and the INSRT clarifying token if necessary as arguments.
 It has a more sophisticated memory management system though.
 If the end of the new clarified clause token buffer (OCLAUSE for direct
 object and IClause for indirect object) is close to the start of the clause
 that is going to be copied, the routine will not the clarified clause token
 buffer but modify the source clause by shifting over tokens to create space
 for the clarifying tokens to be inserted.
 This is to prevent an overrun of the clause token buffer into other buffers.
 Otherwise, it functioned very similar to the 
\series bold
Moonmist
\series default
.
 It did skip over moving the recently added tokens in the destination token
 buffer to the front of it if the source token buffer is the same as the
 destination token buffer.
 This is because they will be automatically inserted to the front of the
 destination token buffer.
\end_layout

\begin_layout Standard

\series bold
The Lurking Horror
\series default
 allowed for a noun clause to be the clarifying information, not just a
 token as in previous versions of CLAUSE-COPY.
 Another argument, along with the original INSRT, to represent the start
 and end addresses of the tokens to insert when the ambiguous token is found.
\end_layout

\begin_layout Standard

\series bold
Beyond Zork
\series default
 used the more simple version in 
\series bold
Moonmist
\series default
 but did not need CC-TBL like 
\series bold
Bureaucracy
\series default
.
\end_layout

\begin_layout Section
SYNTAX-CHECK: Find Correct Syntax Entry
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Return: TRUE if syntax matched, Syntax number if matched using GWIM, or
 FALSE for all errors or orphaned commands
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Given the verb, any prepositions, and any direct and indirect clauses, the
 game will need to see which valid syntax structure for the given verb best
 matches.
 Different usages of the same verb can require different prepositions and
 noun clauses (for example: TAKE LETTER, TAKE LETTER FROM MAILBOX, TAKE
 LETTER TO BOB).
 These combinations are stored as syntax entries.
 SYNTAX-CHECK will attempt to find the best match.
 If no perfect match can be found, GWIM is called to try to replace any
 needed missing objects.
 If that also fails to completely match a syntax entry, an orphan command
 will be created with ORPHAN.
 
\end_layout

\begin_layout Subsection
Hierarchy of Matching
\end_layout

\begin_layout Standard
SYNTAX-CHECK will try to match the command’s combination of verb, prepositions,
 and object clauses with one of the verb’s syntax entries.
 If it cannot find a perfect match because of missing information, it will
 return the best fitting entry based upon a specific hierarchy.
\end_layout

\begin_layout Standard
First, SYNTAX-CHECK will check if a verb is given.
 If not, then show an missing verb error and return FALSE.
 Up to 2 noun clauses are allowed in a syntax entry.
 If SYNTAX-CHECK finds a complete match as it loops through all the verb’s
 syntax entries, it will return that syntax entry’s action number.
\end_layout

\begin_layout Subsection
GWIM (Get What I Mean)
\end_layout

\begin_layout Description
Arguments: GWIMBIT number, LOC byte
\end_layout

\begin_layout Description
Return: Object number if only 1 match, False if no or more than 1 object
 matched
\end_layout

\begin_layout Standard
If there is no complete match, SYNTAX-CHECK will call GWIM to try to match
 any missing object clauses with a local object to create a complete match,
 favoring a missing direct object clause over indirect object.
 For example, the command IGNITE PAPER would typically cause an error as
 the game does not know what object to use to ignite the paper (the indirect
 object clause is missing).
 GWIM uses GET-OBJECT to search for a local object that has a specific attribute
 flag (GWIMBIT) set and returns that object.
 In that example, the GWIMBIT would be the attribute to indicate an object
 is a source of fire.
 If a local object was a TORCH and it was on fire, then GWIM would display
 the clarification and return TORCH:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

IGNITE PAPER
\end_layout

\begin_layout Plain Layout

[with the torch]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
GWIM first checks if the passed GWIMBIT is the RMUNGBIT (AKA KLUDGEBIT).
 If so, the ROOMS object is returned.
 After setting the global SLOCBITS and GWIMBIT variables and resetting the
 number of objects in the MERGE table, GET-OBJECT will try to match any
 object in the current location with a GWIMBIT set.
 If none or more than 1 object is found, then return false.
 If only 1 object is matched, then return that object.
 Also, GWIM will display a small amount of text in parentheses or brackets
 to describe which object was matched.
 It may also have additional text to clarify the matched objects (for example,
 if it is in your hand).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
ORPHAN: Creating an Orphaned Command
\end_layout

\begin_layout Description
Arguments: Address of syntax entry with missing direct object, Address of
 syntax entry with missing indirect object
\end_layout

\begin_layout Description
Return: True
\end_layout

\begin_layout Standard
If a the command given or completed by using GWIM does not completely match
 any valid syntax entries, SYNTAX-CHECK will call ORPHAN to setup an orphaned
 command.
 It is also called by GET-OBJECT (described later) if too many objects match
 the given adjective and noun in a clause.
 ORPHAN will first copy the data from ITBL to OTBL.
 If an indirect object clause is given (possibly has ambiguous words), the
 indirect object tokens from LEXV are appended into OCLAUSE.
 Then, if a direct object clause is given (possibly has ambiguous words),
 the direct object tokens from LEXV are appended into OCLAUSE.
 So the indirect object tokens are placed before the direct object tokens
 in OCLAUSE.
 When called by SYNTAX-CHECK, it also copies the corresponding preposition
 number (if any) for the missing noun clauses into the OTBL.
 ORPHAN then stores $01 as the start address of the missing or ambiguous
 noun clauses in the OTBL to indicate that clause has a missing or ambiguous
 word.
 Finally, SYNTAX-CHECK will then set the O-FLAG and offer clarifying information
 for the player to help supply the missing information.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/SyntaxCheck.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Syntax Check
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset

Possible Outcomes:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Syntax Entry Command
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 object clauses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 object clause
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 object clauses
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 object clauses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All prepositions should be all blank.
 Return Action number
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If DO preposition matches or command preposition is missing, then DO Is
 missing.
 Save syntax entry address in DO missing var.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If DO preposition matches or command preposition is missing, then DO is
 missing.
 Save syntax entry address in DO missing var.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 object clause
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All prepositions should be all blank.
 Return Action number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If DO preposition matches and indirect object preposition is blank, then
 get Action number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If DO preposition matches, then IO is missing.
 Save syntax entry address in IO missing var.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 object clauses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All prepositions should be all blank.
 Return Action number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If DO preposition matches and indirect object preposition is blank, then
 get Action number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If direct and indirect object prepositions match, then get Action number
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Update: SYNTAX-CHECK
\end_layout

\begin_layout Standard
No major changes were made in SYNTAX-CHECK except for a check on the number
 of noun clauses in the input.
 If it was greater than the number in the syntax entry, then it would bypass
 checking for orphaned clauses as it isn’t possible.
 Also, the error messaging was more specific depending on what piece of
 information was missing such as using “WHO” or “WHERE” when appropriate
 and if the WINNER Is the PLAYER or a different actor.
 Some games check for specific verbs that will not generate an orphaned
 command.
\end_layout

\begin_layout Standard

\series bold
Mini-Zork
\series default
 did use a new compact format for the syntax entries that was also used
 in 
\series bold
Sherlock
\series default
.
 No other released Infocom game used it.
 The size of the entry depended on the number of objects in the entry.
 The number of objects is stored in the highest 2 bits of byte 1.
 The preposition number for the direct object is reduced by $C0 and stored
 in the lower 6 bits of byte 1.
 The preposition number for the indirect object is also reduced by $C0 and
 stored in the lower 6 bits of byte 5.
 However, the top 2 bits are not used in byte 5.
 The syntax token byte is composed to flags that refer to the LOC tokens
 referred earlier.
\end_layout

\begin_layout Standard
The structure of the syntax entries for no objects is:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="10text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 high bits = number of object clauses
\begin_inset Newline newline
\end_inset

6 low bits = Preposition number for direct object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action number
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset

The structure of the syntax entries with only direct objects is:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 high bits = number of object clauses
\begin_inset Newline newline
\end_inset

6 low bits = Preposition number for direct object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action number
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT number for direct object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte for direct object
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

The structure of the syntax entries with direct and indirect objects is:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="7">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 high bits = number of object clauses
\begin_inset Newline newline
\end_inset

6 low bits = Preposition number for direct object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action number
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT number for direct object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte for direct object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prep number for indirect object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GWIMBIT number for indirect object
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOC byte for indirect object
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

These variable sized entries help eliminate any wasted space in the syntax
 entry blocks.
 SYNTAX-CHECK and SYNTAX-FOUND were adjusted to use this different format.
\end_layout

\begin_layout Subsection
Update: New versions of GWIM
\end_layout

\begin_layout Standard
Many games used modified GWIM routines that would add extra clarifying text
 such as “of”, “at” or “in” when commenting to the user about an object
 matched because of a command with a specific preposition.
 
\series bold
The Witness
\series default
 would use a special string to refer to an object matched by GWIM instead
 of the standard object name.
 For example, GWIM will use “Asian man” preceded by “the” instead of the
 object’s name, “Mr.
 Phong”.
 
\series bold
Trinity
\series default
 introduced an initial check of the GWIMBIT in the IT-OBJECT if it is set
 to an object.
 The routine will return what the object that is referenced by IT-OBJECT.
\end_layout

\begin_layout Subsection
Update: New versions of ORPHAN
\end_layout

\begin_layout Standard

\series bold
HGTG
\series default
 introduce a new method for handling orphaned commands with the introduction
 of the game’s new CLAUSE-COPY (see above).
 For its ORPHAN routine, it made sure OCLAUSE was cleared if P-MERGED is
 also clear and also copied over VTBL to OVTBL.
\end_layout

\begin_layout Standard

\series bold
Mini-Zork
\series default
 has a modified ORPHAN because it uses a modified syntax entry format.
 Instead of manually getting the preposition number from the syntax entry,
 
\series bold
Mini-Zork
\series default
 calls a separate routine that extracts is from the modified syntax entry
 format.
 Version 4 and 5 games could call CLAUSE-COPY with more arguments and needed
 fewer global variables.
 So CC-TBL was not needed anymore.
 Version 5 games used the same routine as the Version 4 games but using
 the COPY-TABLE command that replaced the manual copying loop in ORPHAN.
\end_layout

\begin_layout Standard

\series bold
Bureaucracy
\series default
 uses the same routine as 
\series bold
AMFV
\series default
 except it copies the object clauses into separate token buffers, OCLAUSE
 for the direct object tokens and IClause for the indirect object tokens.
\end_layout

\begin_layout Section
Getting Objects with SNARF-OBJECTS
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Return: TRUE if objects found, FALSE if no objects found
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
After finding the best syntax entry and any local objects to represent missing
 objects in the given command, SNARF-OBJECTS looks for the objects mentioned
 in the direct and indirect object clauses by calling two other routines
 on each clause:
\end_layout

\begin_layout Standard
SNARFEM to find all the objects mentioned in the noun clause
\end_layout

\begin_layout Standard
BUT-MERGE to remove all the exception objects not wanted by the user
\end_layout

\begin_layout Standard
The matched objects have their numbers stored into the appropriate tables,
 P-PRSO and P-PRSI.
\end_layout

\begin_layout Subsection
Setting up Routines
\end_layout

\begin_layout Standard
SNARF-OBJECT simply sets up the variables needed by SNARFEM: start and end
 addresses of direct object clause and address of table to store extracted
 objects, P-PRSO.
 After calling SNARFEM, BUT-MERGE is called to remove any exception objects
 from BUTTABLE if any exists.
 This is repeated using the indirect object clause and P-PRSI.
 If there is only one object in P-PRSI and there are exception objects,
 SNARF-OBJECT assumes the exception objects will apply to the P-PRSO and
 call BUT-MERGE again on P-PRSO.
 For example, the command:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

CUT ALL EXCEPT NEWSPAPER
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is interpreted as multiple CUT commands on all the local objects except
 the newspaper.
 Similarly, the command:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

ATTACK ALL PIRATES WITH ALL GUNS EXCEPT RIFLE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
has the RIFLE object removed from the indirect objects referenced by ALL
 GUNS.
 However, the following command:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

EAT ALL FRUITS WITH FORK EXCEPT APPLE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
has the EXCEPT object applied to the direct objects this time as trying
 to apply it to the indirect objects could actually eliminate the only object
 in the indirect clause and generate an error.
\end_layout

\begin_layout Subsection
SNARFEM: Looking for Groups of Objects
\end_layout

\begin_layout Description
Arguments: Start address to noun clause, End address to noun clause, Address
 to object table
\end_layout

\begin_layout Description
Return: True if objects extracted, False if no objects extracted
\end_layout

\begin_layout Standard
SNARFEM searches the noun clause for adjectives, nouns, and quantity (like
 ALL or ONE) tokens that describe one object or a single group of objects.
 Any found adjectives or nouns will have their values saved in the global
 variables P-ADJ and P-NAM respectively.
 If multiple adjectives or nouns are given, then only the most recent ones
 are saved in those variables.
 Any other tokens like conjunctions, exceptions (like BUT), or different
 quantity tokens indicate no more tokens to describe an object and triggers
 GET-OBJECT to be called which matches a local object with the given adjective
 and noun.
 Quantity tokens change how many objects are matched by GET-OBJECT by changing
 GETFLAGS.
 Exception tokens change where GET-OBJECT saves those matched objects.
 Details are below:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="35text%">
<column alignment="left" valignment="top" width="55text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Token
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ALL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set P-GETFLAGS to $01 (ALL mode)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ALL + OF
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set P-GETFLAGS to $01 (ALL mode) and skip over OF token
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BUT or EXCEPT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If BUT table not being used, then call GET-OBJECT with TBL and switch to
 BUT table for subsequent storage.
 Otherwise, call GET-OBJECT with BUT.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A or ONE (no adjective set)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set P-GETFLAGS to $02 (ONE mode)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A + OF or ONE + OF (no adjective set)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set P-GETFLAGS to $02 (ONE mode) and skip over OF token
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A or ONE (adjective already set)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Copy ONEOBJ into NAM.
 Call GET-OBJECT with the currently used table (TBL or BUT).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AND or “,”
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Call GET-OBJECT with the currently used table (TBL or BUT)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AND or “,” + AND or ”,”
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ignore first conjunction token and continue processing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Buzzwords
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Skip over this token
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OF (ALL, A, or ONE not given)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set P-GETFLAGS to $04 (INHIBIT mode).
 Ignore this object as it is an error in syntax.
 Of note, PARSER already ignores any adjective or noun with “OF” at the
 start of a clause.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adjective
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set ADJ to adjective value and Dictionary address of adjective into ADJN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noun
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set Dictionary address of noun into NAM and ONEOBJ (just in case)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All other tokens
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Skip over this token
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No more tokens
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Call GET-OBJECT with the currently used table (TBL or BUT)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

For example, ALL OF THE CANDLES is the treated the same as ALL CANDLES.
 Also, A BLUE CARD AND A RED ONE is interpreted as A BLUE CARD AND A RED
 CARD with ONE referring to the just given noun CARD.
 ONE OF THE FLOWERS is seen as ONE FLOWERS.
\end_layout

\begin_layout Standard
If BUT or EXCEPT have not been given, any numbers for found objects will
 be saved in table found in the third argument.
 Once BUT or EXCEPT have been given, all found objects will be saved in
 BUT table.
\end_layout

\begin_layout Subsection
BUT-MERGE
\end_layout

\begin_layout Description
Arguments: Address to object table
\end_layout

\begin_layout Description
Return: P-MERGE (address to merged object table)
\end_layout

\begin_layout Standard
This routine copies the objects in the given table into the MERGE table
 but skips over any objects in an exception (BUTS) table.
 It uses ZMEMQ to see if the given object is in BUTS.
 While the routine returns to address to the MERGE table.
 It will also put the address of the given object table into MERGE.
\end_layout

\begin_layout Subsection
Getting Object Numbers for each Object with GET-OBJECT
\end_layout

\begin_layout Description
Arguments: Address to Object table, Verbose flag
\end_layout

\begin_layout Description
Return: TRUE if successful in getting appropriate number of object, FALSE
 for any error
\end_layout

\begin_layout Standard
GET-OBJECT tries to find a local object that matches the given identifiers
 (adjective, noun, and GWIMBIT) and stores that object number in the given
 object table.
 It will limit the matched objects depending on what GETFLAGS mode (default,
 ALL, ONE, or INHIBIT) is set by SNARFEM.
 SLOCBITS is first set to #FFFF (all flags set) to ensure the greatest chance
 of matching an object to the identifiers.
 If a clause’s SLOCBITS is set to a non-zero value from the matching syntax
 and the match mode is ALL, then that clause’s SLOCBITS is used.
\end_layout

\begin_layout Standard
GET-OBJECT requires that a noun is at least given in the command.
 If there is no noun, then the adjective will be used as a noun if possible.
 For example, “gold” can be an adjective or a noun like in “piece of gold”.
 If the adjective cannot be a noun, the routine will display a missing noun
 error and quit.
 Now, GET-OBJECT will look for objects in the WINNER and current location
 (if lit) using DO-SL.
 Any found objects are saved into the given object table.
 The processing of the objects depends on the mode:
\end_layout

\begin_layout Itemize
ALL: Search using DO-SL and return true
\end_layout

\begin_layout Itemize
INHIBIT: Return true
\end_layout

\begin_layout Itemize
ONE: Search using DO-SL or GLOBAL-CHECK found:
\end_layout

\begin_deeper
\begin_layout Itemize
0 objects (using DO-SL): Search again using GLOBAL-CHECK
\end_layout

\begin_layout Itemize
0 objects (using GLOBAL-CHECK): Give a CAN’T SEE error and return false.
\end_layout

\begin_layout Itemize
1 object: Return true.
\end_layout

\begin_layout Itemize
>1 objects: Randomly pick one object and move it to the top of the table.
 Set the number of objects to 1.
 Return true.
\end_layout

\end_deeper
\begin_layout Itemize
Default: Search using DO-SL or GLOBAL-CHECK found:
\end_layout

\begin_deeper
\begin_layout Itemize
0 objects (using DO-SL): Search again using GLOBAL-CHECK
\end_layout

\begin_layout Itemize
0 objects (using GLOBAL-CHECK): Give a CAN’T SEE error and return false.
\end_layout

\begin_layout Itemize
1 object: Return true.
\end_layout

\begin_layout Itemize
>1 objects: Restore SLOCBITS from matched syntax entry.
 Search again with same method:
\end_layout

\begin_deeper
\begin_layout Itemize
0 or >1 objects: Create an orphaned command by setting the ambiguous variables
 (AADJ, ANAM, and OFLAG) and call OPRHAN (Initial search had >1 but second
 search had 0 or >1 objects matched which is an ambiguous situation.) Return
 false.
\end_layout

\begin_layout Itemize
1 object: Return true.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
The identifiers, ADJ and NAM, are always cleared after GET-OBJECT is called
 except if in INHIBIT mode.
 If a correct number of objects is found, then the routine also restores
 the SLOCBITS to what is listed in the matching syntax.
\end_layout

\begin_layout Subsection
Bug: Randomly Picking Objects
\end_layout

\begin_layout Standard
When only one object is requested like in:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

GET ONE CARD
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in a room with multiple cards (blue card, red card, etc), GET-OBJECT will
 randomly choosing one object.
 However, the routine places this chose object in the first position of
 the object table.
 If there is an object already in the first position, it will be overwritten.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

GET FLASHLIGHT AND ONE CARD
\end_layout

\end_inset


\end_layout

\begin_layout Standard
SNARFEM will call GET-OBJECT on FLASHLIGHT and put that object number in
 the first position of the object table.
 SNARFEM will then call GET-OBJECT on ONE CARD.
 Since there are multiple cards in that room, GET-OBJECT will randomly pick
 one and store it in place of FLASHLIGHT.
\end_layout

\begin_layout Standard
Another bug is that the randomly picked item could also picked outside of
 the group of matching objects.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

GET FLASHLIGHT AND LETTER AND ONE CARD
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in a room with three cards, GET-OBJECT will try to randomly pick one of
 the three cards.
 If the random number is 1, GET-OBJECT will pick the object in the first
 position which is FLASHLIGHT.
\end_layout

\begin_layout Subsection
Update: New versions of SNARF-OBJECTS
\end_layout

\begin_layout Standard

\series bold
Zork 1-R88
\series default
 added an P-AND flag to help with displaying lists of objects properly and
 to have a hierarchy of adjectives when referring to objects.
 Only the first adjective is used.
 All subsequent adjectives are ignored before calling GET-OBJECT.
\end_layout

\begin_layout Standard

\series bold
Sorcerer-R18
\series default
 processed the indirect clause first and then the direct object clause.
 However processing the exception objects is saved until the end with it
 trying to apply it to the direct object clause first.
 If nothing happens then it will try to apply the exception objects to the
 indirect objects.
 If there are no direct objects then any exception clause will be applied
 to the indirect object.
 Most of the games since the 
\series bold
Sorcerer-R18
\series default
 had SNARFEM check if P-GETFLAGS was in ALL mode before starting.
 If so, it would set GETFLAGS back to ALL mode after completing its SNARFEM.
\end_layout

\begin_layout Standard

\series bold
LGOP
\series default
 set a global variable, CurrentNounClause, which is used by SNARFEM and
 SaveNAMAdj, when objects cannot be found.
 This allows ambiguous nouns or adjectives for the direct and indirect clauses
 to be stored separately.
 The game also added several more checks in the routine.
 If an ALL, BOTH, or EVERYTHING token is found, the routine will call MANY-CHECK
 to see if the syntax allows for multiple objects to be processed.
 It also checks if the token is profane and provides an error message.
 Finally, there is a check for certain adjectives.
\end_layout

\begin_layout Standard

\series bold
Bureaucracy
\series default
 added a check on the number of indirect objects if an exception was to
 be applied.
 If there is only 1 indirect object, it would assume the exception objects
 would refer to the direct objects.
 Trying to apply the exception objects on a single indirect object could
 remove it.
\end_layout

\begin_layout Standard

\series bold
Sherlock
\series default
 call SNARFEM and EXCEPTION on different clauses depending on how many object
 clauses are in the syntax entry which needs to be specially extracted with
 the compact format.???
\end_layout

\begin_layout Subsection
Update: New versions of SNARFEM
\end_layout

\begin_layout Standard

\series bold
Sorcerer-R6
\series default
 allowed special spell related word when referring to objects.
 
\series bold
Seastalker
\series default
 similarly allowed numbers and also had SNARFEM ignore any additional adjectives
 given when referring to an object.
 Only the first adjective is used.
\end_layout

\begin_layout Standard

\series bold
HGTG
\series default
 checks if the GETFLAGS was in ALL mode.
 If so, the GETFLAGS is cleared (changed to default mode) and will restore
 the GETFLAGS back to the ALL mode once SNARFEM is complete.
\end_layout

\begin_layout Standard

\series bold
LGOP
\series default
 will check if a syntax entry will allow multiple objects if “all” or “both”
 is given with an object.
 It will be rechecked again toward the end of the PARSER routine.
\end_layout

\begin_layout Standard

\series bold
Hollywood Hijinx
\series default
 does allow for two adjectives to be given for some objects and has a separate
 routine to check for valid combinations when a second adjective is found.
\end_layout

\begin_layout Standard
Other games will have checks for profanity which is not allowed when referring
 to objects.
\end_layout

\begin_layout Subsection
Update: New BUT-MERGE
\end_layout

\begin_layout Standard
The only major change was with 
\series bold
AMFV
\series default
 and other version 4 and 5 games was the use of SCAN_TABLE operator instead
 of the ZMEMQ routine.
 Though various parameters had to be calculated, the new operator could
 quickly look for a found objects in the exception table.
\end_layout

\begin_layout Subsection
Update: New ways to GET-OBJECT
\end_layout

\begin_layout Standard
Every game seems to have used their own special version of GET-OBJECT.
 Those modifications included special checks for certain actions or with
 certain objects and displaying special errors for certain situations.
 However, improvements were made over successive games.
\end_layout

\begin_layout Standard

\series bold
Zork 1-R88
\series default
 added a check if the WINNER is also the PLAYER if there is an orphaned
 command.
 If so, then error that it can’t be orphaned.
\end_layout

\begin_layout Standard

\series bold
Zork 2-R23
\series default
 added a new WHICH-PRINT routine which also lists the possible objects for
 the user to choose from when the noun is ambiguous.
 It also ensured that the PLAYER can also be checked for objects if the
 WINNER needing objects is not the PLAYER.
\end_layout

\begin_layout Standard

\series bold
Zork 3
\series default
 added an early check if the adjective could also be a direction.
 If so, then it is saved in the DIR variable and ensures the “direction”
 object is the only entry in the object table.
 More detailed error messages were added for various situations.
\end_layout

\begin_layout Standard

\series bold
Suspended
\series default
 had a unique GET-OBJECT as the player did not interact directly with the
 environment.
 So the GET-OBJECT was more liberal when searching for objects.
 It would ensure the SLOCBIT was #FFFF for all “get” commands.
\end_layout

\begin_layout Standard

\series bold
The Witness
\series default
 introduced the GENERIC property which contains a routine address used to
 clarify a requested object.
 If multiple objects match a given NAM instead of just one, the routine
 address in the GENERIC property will be called.
 This routine will then try to determine which specific object was requested
 based upon various variable values and return that object number.
 There is no check to see if the GENERIC property is set.
 If it is blank, it will just return FALSE.
 GET-OBJECT will then default to providing an error message and display
 the possible objects to choose from.
 Also, the NOT-HERE-OBJECT was introduced.
 For any unmatching identifiers, the NOT-HERE-OBJECT would be returned for
 counting purposes.
 The unmatched NAM and ADJ are then saved into XNAM and XADJ.
\end_layout

\begin_layout Standard

\series bold
Planetfall
\series default
 did all for searching the WINNER if in ALL mode only if the WINNER was
 not the player.
\end_layout

\begin_layout Standard

\series bold
Sorcerer-R15
\series default
 did limit the created of NOT-HERE-OBJECT and XNAM/XADJ only if the room
 was lit or for specific actions.
\end_layout

\begin_layout Standard

\series bold
AMFV
\series default
 introduced having a separate NAM and ADJ for direct and indirect object
 clauses.
 They are stored in separate two word tables with the first element in each
 is for the direct clause.
 It was used by certain actions to check the current noun or adjective in
 use.
 It use was later expanded in 
\series bold
LGOP
\series default
.
\end_layout

\begin_layout Standard

\series bold
LGOP
\series default
 did save the identifiers for the direct and indirect objects in different
 locations when an object is matched.
 It also fixed the situation where the requested object is a vehicle that
 the WINNER is inside of.
\end_layout

\begin_layout Standard

\series bold
Spellbreaker
\series default
 also including the searching a vehicle for the requested object if its
 open.
 In the few situations, that multiple objects are matched, a separate routine
 is called to see if all the objects have the same GENERIC routine.
 If so, the GENERIC routine will be called to clarify which object was requested.
\end_layout

\begin_layout Standard
Some games will have extra checks for non-matched objects to see if they
 are part of a special case.
 This is primarily for spell names.
\end_layout

\begin_layout Standard

\series bold
Bureaucracy
\series default
 does add a creative error message if OCLAUSE or IClause has more than 10
 tokens in it.
\end_layout

\begin_layout Standard

\series bold
The Lurking Horror
\series default
 saves the first 4 adjective identifiers and their corresponding tokens
 for any object.
 If multiple adjectives are given, it will see if the last one can also
 be a noun.
 If that is the case, it will assign that token to NAM and decrease the
 number of adjectives.
\end_layout

\begin_layout Section
Search for Objects using SEARCH-LIST
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Another one of the interesting aspects of Infocom games is how it searches
 and matches objects to those requested by the player.
 It will use various methods to find these objects and collect them into
 a table.
\end_layout

\begin_layout Subsection
SEARCH-LIST: Finding Objects in Room and on Winner
\end_layout

\begin_layout Description
Arguments: Number to Object to search inside, Address to object table, Search
 level (0-2)
\end_layout

\begin_layout Description
Return: Number of objects found
\end_layout

\begin_layout Standard
When the user refers to objects in a command, PARSER needs to see which
 objects are referred and accessible.
 The given noun, adjective, and/or GWIMBIT will be used as identifiers for
 a particular object.
 SEARCH-LIST will check the objects in a given location (a room or person)
 and see if it matches these identifiers.
 There are 3 levels of search which affects which objects are checked:
\end_layout

\begin_layout Itemize
Search-TOP/Type 0: ON-GROUND or HELD (reachable objects)
\end_layout

\begin_deeper
\begin_layout Itemize
Look at objects that are on “top” of all objects
\end_layout

\begin_layout Itemize
Match against all non-container objects and objects on surfaces in the location.
 Any containers (if they are open or transparent) and surfaces on the surface
 are checked completely.
\end_layout

\end_deeper
\begin_layout Itemize
Search-ALL/Type 1 (all objects)
\end_layout

\begin_deeper
\begin_layout Itemize
Match against all objects in the location.
 Only containers that are open or transparent will be searched.
\end_layout

\end_deeper
\begin_layout Itemize
Search-BOT/Type 2: IN-ROOM or CARRIED (contained objects)
\end_layout

\begin_deeper
\begin_layout Itemize
Look inside any containers (look at second-level or any non-top level)
\end_layout

\begin_layout Itemize
Match against all objects on any surface and inside any open or transparent
 container.
\end_layout

\end_deeper
\begin_layout Standard
The matched objects are saved in the table addressed passed to SEARCH-LIST.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/SearchObject.png
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search Object
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, SEARCH-LIST is examining Room/Person 1.
 For each search mode, the listed objects will be checked:
\end_layout

\begin_layout Standard
TOP: Obj 1,1, Surface 1,2 (Obj 1,2,1, Cont 1,2,2 (Obj 1,2,2,1))
\end_layout

\begin_layout Standard
BOT: Surface 1,2, Cont 1,4 (Obj 1,4,1, Surface 1,4,2 (Obj 1,4,2,1), Cont
 1,4,3 (Obj 1,4,3,1))
\end_layout

\begin_layout Standard
ALL: Obj 1,1, Surface 1,2 (Obj 1,2,1, Cont 1,2,2 (Obj 1,2,2,1)), Surface
 1,2, Cont 1,4 (Obj 1,4,1, Surface 1,4,2 (Obj 1,4,2,1), Cont 1,4,3 (Obj
 1,4,3,1))
\end_layout

\begin_layout Standard
Object Cont 1,3 is invisible.
\end_layout

\begin_layout Standard
All Infocom games appeared to be using the same SEARCH-LIST routine.
\end_layout

\begin_layout Subsection
DO-SL: Find Objects Based Upon Search Level
\end_layout

\begin_layout Description
Arguments: Number of object to search, LOC value to SRC-TOP, LOC value to
 SRC-BOT
\end_layout

\begin_layout Description
Return: Number of objects found
\end_layout

\begin_layout Standard
DO-SL calls SEARCH-LIST with the appropriate search type depending on the
 LOC flags given in the arguments and the LOC flags in the matched syntax
 entry.
 If 1 is used for both DO-SL arguments then, SEARCH-LIST will perform a
 SRC-ALL match.
 All matched objects will be saved in P-TABLE.
\end_layout

\begin_layout Standard
GET-OBJECT calls DO-SL with the ON-GROUND and IN-ROOM flags to look for
 any objects in the given location for use with the current syntax entry.
 Similarly, GET-OBJECT also calls it with the HELD and CARRIED flags to
 look for objects on the PLAYER.
 All other calls to DO-SL seem to mainly use the double 1 parameter which
 will match anything.
\end_layout

\begin_layout Standard
All Infocom games appeared to be using the same DO-SL routine.
\end_layout

\begin_layout Subsection
GLOBAL-CHECK: Look for Objects Everywhere
\end_layout

\begin_layout Description
Arguments: Address to object table
\end_layout

\begin_layout Description
Return: True if GLOBALs checked, False if object matched from local-globals
 or PSEUDO objects
\end_layout

\begin_layout Standard
Some objects in a game may be accessible from more than one locations and
 valid objects to be used with certain actions.
 GLOBAL-CHECK is the routine that tries to find these potentially valid
 objects.
 Infocom had three different types of these special objects: GLOBALS, LOCAL-GLOB
ALS, and PSEUDO objects.
\end_layout

\begin_layout Standard
GLOBALS can be accessed from any location in the game.
 If a game had an AIR object, that would likely be accessible from any location.
 Remember, these are not necessarily rooms.
 LOCAL-GLOBALS are accessible from multiple locations but not all.
 The best example is a door which would be accessible from the two rooms
 that are separated by it.
 PSEUDO (or virtual) objects are the most confusing of the three objects
 as they are not actual objects.
 They only have the SYNONYMS (nouns) and ACTION properties.
 A given location can have PSEUDO objects that are matched if certain nouns
 are used in that location.
 The routine then jumps to a different routine for each noun that will figure
 out what is the object the user was referencing.
 So a bed object in two different rooms could be handled with a routine
 instead of creating multiple objects.
\end_layout

\begin_layout Standard
GLOBAL-CHECK will first try to match any identifiers (noun/NAM, adj/ADJ,
 or GWIMBIT) to any object in the GLOBAL property (AKA LOCAL-GLOBALS) of
 the current location.
 The number to any matched objects will be added to P-TABLE.
 The routine does not search inside the local-global objects.
 Next, the PSEUDO property is checked which contains a list of 2 word pairs.
 The first word is the Vocabulary address to the noun that references the
 pseudo object while the second word is an ACTION routine address.
 If the object matches, the Z-string of the matching noun and ACTION addresses
 are saved into a pseudo object’s description and ROUTINE properties, respective
ly, which is then saved to P-TABLE.
 GLOBAL-CHECK will continue to check the remaining objects in PSEUDO and
 save any matches.
 If no objects have matched by this point, the GLOBAL-OBJECTS are searched
 using DO-SL on GLOBAL-OBJECTS.
 SLOC-BITS is temporarily set to $FFFF which makes any match valid and restored
 afterwards.
\end_layout

\begin_layout Subsection
THIS-IT?
\end_layout

\begin_layout Description
Arguments: Object number
\end_layout

\begin_layout Description
Return: True if object matches
\end_layout

\begin_layout Standard
Infocom games can use three different identifiers to see if an object matches
 the one requested in a command: noun (P-NAM), adjective (P-ADJ), and GWIMBIT.
 THIS-IT? will see if the given object matches any of these identifiers.
 First, the routine will see if the object is visible.
 So invisible (or hidden) objects cannot be matched.
 THIS-IT? will then see if the given noun (if it exists) matches any of
 the Vocabulary addresses in the SYNONYMS property of the object.
 It will do a similar check with the given adjective (if it exists) with
 the addresses in the ADJECTIVE property.
 Finally, it will see if the GWIMBIT (if given) is set on the object.
 If the given information matches, THIS-IT? returns true.
\end_layout

\begin_layout Subsection
Update: New version of SEARCH-LIST
\end_layout

\begin_layout Standard
Only a few major changes were added to SEARCH-LIST.
 
\series bold
Zork 2
\series default
 had the addition of the SEARCHBIT attribute for objects which made it easy
 to restrict what objects could be searched inside of.
 
\series bold
Deadline
\series default
 checked the SYNONYM property for an object.
 If that property was not set, the object was not searched as it is not
 likely a “real” object.
 Some games would use the SEE-INSIDE? predicate (instead of hard coded)
 to determine which objects could be searched inside.
\end_layout

\begin_layout Subsection
Update: New version of GLOBAL-CHECK
\end_layout

\begin_layout Standard
The first addition was the checking if the request was made for certain
 actions in 
\series bold
Deadline
\series default
.
 If so, an additional search using DO-SL with any flags on all ROOMs in
 the game was done.
 Other games like 
\series bold
Wishbringer
\series default
 and 
\series bold
Bureaucracy
\series default
 had would also search the objects contained inside LOCAL-GLOBALS.
 
\series bold
Sherlock
\series default
 also included this but limited it to objects that were actually rooms.
 
\series bold
Sorcerer
\series default
 introduced setting the location of the PSEUDO object to the current location
 in case a routine needed to know that.
 
\series bold
Wishbringer
\series default
 also expanded the search of LOCAL-GLOBALS by having GLOBAL-CHECK also search
 inside those objects if possible.
\end_layout

\begin_layout Standard

\series bold
LGOP
\series default
 introduced a new property, THINGS, which replaced PSEUDO that added adjectives
 for THIS-IT? to match.
 THINGS would contain entries with a single adjective (if necessary) and
 a noun with an associated ROUTINE address.
 If any given noun or adjective does not match the values in an entry in
 THINGS, GLOBAL-CHECK will proceed to the next entry.
 If there is a match, the PSEUDO objects values are set as previously described.
\end_layout

\begin_layout Standard
Several games did you a more abbreviated form of GLOBAL-CHECK.
 This was first done with 
\series bold
AMFV
\series default
.
 After searching through the current locations local-globals, DO-SL with
 SRCALL was called on all the game’s room objects which essentially searched
 all visible objects in the game.
 
\series bold
Bureaucracy
\series default
 did not use a typical THINGS or PSEUDO property.
 It used a new property which had a routine address and 1 word argument.
 This routine would then be called with the noun, adjective, and stored
 argument.
 An object number could then be returned and later saved in TBL.
\end_layout

\begin_layout Subsection
Update: New version of THIS-IT?
\end_layout

\begin_layout Standard
Some of the games added checks to quit this routine sooner.
 such as a blank SYNONYM or ADJECTIVE property.
 
\series bold
AMFV
\series default
 removed the INVISIBLE flag check.
 
\series bold
Bureaucracy
\series default
 added a special check if the given object is “intnum”.
 The P-NUMBER value will then be compared to prop 20 in 2 specific objects
 (flight number or leaflet).
 Also added various situations where the object given will not be matched
 with the identifiers.
 
\series bold
The Lurking Horror
\series default
 would check all the NAMs in the G99 table against all the synonyms in an
 object.
 
\series bold
Sherlock
\series default
 also checks any token associated with the given object by “of” like in
 “glass of milk”.
 It will also check the associated token to see if it matches any adjectives
 and/or synonyms for the object.
\end_layout

\begin_layout Subsection
Update: NOT-HERE-OBJECT
\end_layout

\begin_layout Standard
Introduced in 
\series bold
The Witness
\series default
, a new object, NOT-HERE-OBJECT, stood in for any requested objects in a
 command that was not found.
 For example, if the user requested:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

TAKE CANDLE, TORCH, and MATCH
\end_layout

\end_inset


\end_layout

\begin_layout Standard
but the torch was not present, the PRSOTBL would list 3 object numbers:
 one candle, one NOT-HERE-OBJECT, and one match.
 When generating the table of object numbers corresponding to the objects
 requested in a noun clause, any recognized object that was not present
 in the current location had the NOT-HERE-OBJECT number used in its place.
 This occurs in the GET-OBJECT routine.
 So the total number of returned objects is the same as requested.
 The NOT-HERE-OBJECT will also call the GENERIC routine of an object to
 try to clarify which object the player was referencing.
 The use of a NOT-HERE-OBJECT allowed the game to process the remaining
 commands and also provide a more specific error message about the missing
 objects.
\end_layout

\begin_layout Subsection
Update: MOBY-FIND
\end_layout

\begin_layout Description
Arguments: Address to object table
\end_layout

\begin_layout Description
Return: Number of objects found
\end_layout

\begin_layout Standard
I don’t know what MOBY
\begin_inset Foot
status open

\begin_layout Plain Layout

\noun on
Jesse MgGrew
\noun default
: I believe MOBY was slang meaning something like "big" (from Moby Dick,
 the giant whale).
\end_layout

\end_inset

 means, but MOBY-FIND was first used in to search for a match between all
 visible objects (including inside open or transparent objects) in 
\series bold
Suspended
\series default
 using P-NAM, P-ADJ, or GWIMBIT.
 This first version was used when asking about objects to the Advisory Panel.
 It called SEARCH-LIST with SRCALL on all the rooms.
 If no object was matched, MOBY-FIND would call DO-SL to search all of the
 LOCAL-GLOBAL objects with the results saved in P-TABLE.
\end_layout

\begin_layout Standard

\series bold
The Witness
\series default
 had a more formal version of MOBY-FIND by using the noun and/or object
 to search from XNAM and XADJ (replace the values in NAM and ADJ).
 It would sequentially go through every room and find a matching object
 to XNAM and/or XADJ using SEARCH-LIST.
 If no matching objects are found, then MOBY-FIND will use search all LOCAL-GLOB
ALS with DO-SL with SRCALL level matching.
 If no match is found again, then MOBY-FIND will search all the rooms again
 using DO-SL with SRCALL level matching.
 The returns of DO-SL are saved into P-TABLE.
 The returned value is the number of objects found at either step.
 If only one object is matched, its number will be saved into P-MOBY-FOUND
 for easy recall.
\end_layout

\begin_layout Standard

\series bold
Sorcerer
\series default
 changed the final check on the ROOMS object back to SEARCH-LIST.
 
\series bold
AMFV
\series default
 used a more brute force approach but checking each object in the game sequentia
lly.
 If the object is a room, it is skipped.
 Any matched objects are saved in a table with the number of object found
 returned.
\end_layout

\begin_layout Standard

\series bold
Spellbreaker
\series default
 will use a separate routine available on some objects to see if the object
 should be matched during a MOBY-FIND.
 If multiple objects match for the given identifiers in
\end_layout

\begin_layout Standard

\series bold
The Lurking Horror
\series default
 will check the GENERIC property of all the matched objects.
 If the routine address is the same in all the object’s GENERIC property,
 MOBY-FIND will call that routine to decide which object to return as the
 match.
\end_layout

\begin_layout Standard

\series bold
Sherlock
\series default
 has special objects that can be searched at times (Holmes) and some that
 are always available (like local-global objects).
\end_layout

\begin_layout Section
Can Many Objects be TAKEn Before Using with TAKE-CHECK and MANY-CHECK
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
There are now two final checks on the verb by PARSER.
 The first is to see if the given verb can automatically take objects and
 act upon them.
 The second is to see if the given verb can accept multiple objects.
 Both sets of checks are done on direct (and indirect if present) object
 clauses.
\end_layout

\begin_layout Itemize
ITAKE-CHECK (through TAKE-CHECK)
\end_layout

\begin_layout Itemize
MANY-CHECK
\end_layout

\begin_layout Subsection
ITAKE-CHECK (through TAKE-CHECK): Checking TAKE and HAVE bits
\end_layout

\begin_layout Description
Arguments: Address to object table, LOC byte
\end_layout

\begin_layout Description
Returns: TRUE if objects do not need to be taken or were taken if necessary,
 FALSE if errors
\end_layout

\begin_layout Standard
TAKE-CHECK calls ITAKE-CHECK on each set of objects (direct objects from
 P-PRSO and indirect objects from P-PRSI) with the matching syntax’s LOC
 byte to verify if objects must be in the possession of the WINNER to be
 used as some verbs require this.
 So an object in the room but not on the WINNER is not valid.
 However, any verb syntax entry with a TAKE bit set in the LOC byte is allowed
 to automatically put any matching object in the room into the WINNER’s
 inventory and then act upon it.
 PARSER will see if any objects in an object clause that are not in the
 Winner’s inventory can be automatically taken.
 If the object’s TRYTAKEBIT is set, this would prevent PARSER from automatically
 taking it.
 For all objects without the TRYTAKEBIT set, PARSER will call the CARRY
 object routine to move the object into the Winner’s routine.
 For any objects that can’t be automatically taken, it is possible the verb
 can still use it.
 However, PARSER first checks if a HAVE flag is set in the verb syntax entry.
 This would require the object be in the inventory to use it in the action.
 If so, then the object cannot be used and an error is displayed.
 Any error will stop the checking of any remaining objects in the object
 clause.
\end_layout

\begin_layout Subsection
Update: New ITAKE-CHECK
\end_layout

\begin_layout Standard

\series bold
Starcross
\series default
 introduced a new ITAKE-CHECK which tried to catch situations where objects
 could not be taken.
 These included:
\end_layout

\begin_layout Itemize
Both TAKE and HAVE bits cleared (objects do not need to be held and can’t
 be taken) on syntax
\end_layout

\begin_deeper
\begin_layout Itemize
if HAVE set, then check objects
\end_layout

\begin_layout Itemize
if HAVE not set and TAKE not set then RTRUE
\end_layout

\begin_layout Itemize
if HAVE not set and TAKE set then check objects (SEe if can be taken)
\end_layout

\end_deeper
\begin_layout Itemize
The WINNER is not the PLAYER
\end_layout

\begin_layout Itemize
The object is held by the WINNER (using HELD?)
\end_layout

\begin_layout Itemize
The object is something that can’t be taken like “pair of hands”
\end_layout

\begin_layout Standard
The new routine would also not display error messages in certain situations
 such as an ACTOR would try to take an object before using it.
 It also needed to check if the syntax had LOC TAKE set before calling ITAKE
 to get the object.
 (at least try)
\end_layout

\begin_layout Standard

\series bold
Sorcerer
\series default
 checked if the IT-OBJECT was accessible before using it.
 It also checked to see if the object is held, it would then skip the rest
 of the routine.
 For any NOT-HERE-OBJECTs, it would display a specific error message.
 If an object exists but can’t be used, then it would also updated the IT-OBJECT
 value.
\end_layout

\begin_layout Standard

\series bold
Seastalker
\series default
 also allowed “him” and “her” pronouns to be “taken” and used.
 But no checks on their visibility was done until Wishbringer which also
 added the “them” pronoun.
 Later games like 
\series bold
Hollywood Hijinx
\series default
 would have specific checks for objects if they inside other objects (such
 as water inside a bucket).
\end_layout

\begin_layout Standard
More specific error and confirmation messages were created.
 For example, these would use the appropriate articles depending on the
 object and quantifiers depending on the number of objects.
 They would also indicate if an ACTOR did not have an object.
\end_layout

\begin_layout Subsection
MANY-CHECK
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Returns: TRUE if syntax entry accepts multiple objects, FALSE if not
\end_layout

\begin_layout Standard
Some verb syntax entries allow for multiple direct or indirect objects in
 their usage, such as GET or IGNITE.
 PARSER will first check how many objects are in the direct and indirect
 object clauses.
 If there is only 1, then this check is not needed.
 If there is more than 1 object and the MANY token is not set for that direct
 object clause in the syntax entry, then an error message is displayed about
 the verb not being able to use multiple objects.
 This same check is then done on the indirect objects if necessary.
\end_layout

\begin_layout Standard
Only a few changes were made with this routine.
 Starting with 
\series bold
Zork 1-R75
\series default
, PARSER would run MANY-CHECK first before TAKE-CHECK which correct a bug
 were PARSER would attempt to take multiple requested objects first but
 then error out on the verb if it could not process multiple objects.
 By flipping the order, PARSER can quickly see if multiple objects can be
 used on an verb before trying to take then using TAKE-CHECK.
 This is mentioned in the Infocom Cabinet notes.
 
\series bold
Deadline
\series default
 would assume the verb was “tell” if it was not given (occurs when the player
 is telling an actor to do something).
 
\series bold
Sorcerer
\series default
 ensured that the complete verb was displayed if the current command is
 the result of a merge.
 Finally, 
\series bold
LGOP
\series default
 added a new parameter to indicate which noun clause to check.
 This would eliminate the need to check if a particular clause in the matched
 syntax can accept multiple objects.
\end_layout

\begin_layout Section
It's Time to Perform with PERFORM
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
At this point, all necessary information should be checked and processed.
 All the direct and indirect objects and the action number to use those
 objects have been found.
 Many combinations of objects and actions can be handled by the specific
 action routine.
 The designer of Infocom games understood that many actions on objects could
 be handled with a generic verb action routine.
 Any special circumstances usually depend on the objects used.
 Therefore, these circumstances could be checked when accessing those objects
 and not clutter up a generic verb action routine.
\end_layout

\begin_layout Subsection
Checks and Order
\end_layout

\begin_layout Standard
Since action routines can call PERFORM separately from PARSER to perform
 functions that mimic a command, PERFORM does not use the global PRSA, PRSO,
 and PRSI but will be passed a separate action, direct object, and indirect
 object arguments.
 It then temporarily saves the current PRSA, PRSO, and PRSI.
\end_layout

\begin_layout Enumerate
PERFORM will check for the IT object in the direct or indirect object.
 If so, it will be replaced with the previously referenced object for IT.
\end_layout

\begin_layout Enumerate
It will copy all the given arguments (action, direct object, and indirect
 object values) into the appropriate global variables (PRSA, PRSO, PRSI).
\end_layout

\begin_layout Enumerate
If the given action is not GO, PERFORM will then update the IT object to
 the just given direct object argument and update the location of the winner
 to the current location.
\end_layout

\begin_layout Enumerate
If the given action is not AGAIN, PERFORM will update the global variables
 for the last action number, direct object, and indirect object.
 These are used by the AGAIN command.
\end_layout

\begin_layout Standard
After updating the necessary variables, PERFORM will call various routines
 to handle the action on the objects.
 A non-handled action (by returning M-NOT-HANDLE) will be passed to the
 next possible routine to handle it.
 The order of handler preference is below:
\end_layout

\begin_layout Enumerate
WINNER’s action routine
\end_layout

\begin_layout Enumerate
WINNER’s location’s action routine with M-BEG argument
\end_layout

\begin_layout Enumerate
Verb (PRSA) pre-action routine
\end_layout

\begin_layout Enumerate
Indirect object (PRSI) action routine
\end_layout

\begin_layout Enumerate
Direct object (PRSO) action routine (skipping if the action is GO)
\end_layout

\begin_layout Enumerate
Verb (PRSA) action routine
\end_layout

\begin_layout Standard
ACTION routines for objects and rooms can be passed standard RARG values
 for a specific type of function to perform.
 Any needed objects can be found in PRSO and PRSI.
 The routine will then return an action return value.
 If the routine can successfully complete a function, then M-HANDLED is
 return.
 PERFORM will skip over all other subsequent handlers.
 If the routine cannot handle a function, M-NOT-HANDLED is returned.
 PERFORM will then try other handlers to handle the function.
 The verb action routine is considered the default handle routine and can
 always handle an action.
 It usually displays a generic message.
 Once a function has been handled, the current room’s ACTION routine is
 sent M-END to handle any remaining functions before the turn is completed.
 If M-FATAL is ever returned by an action, then PERFORM will exit immediately
 and return M-FATAL.
 Also, the current room’s ACTION routine is not called with M-END.
 Before PERFORM returns, the previous values of PRSA, PRSO, and PRSI are
 restored.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="35text%">
<column alignment="left" valignment="top" width="55text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Room Arguments (RARG)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action Return Values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M-END, 0
\end_layout

\begin_layout Plain Layout
M-BEG, 1
\end_layout

\begin_layout Plain Layout
M-LOOK, 3
\end_layout

\begin_layout Plain Layout
M-FLASH, 4
\end_layout

\begin_layout Plain Layout
M-OBJDESC, 5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M-NOT-HANDLED, 0
\end_layout

\begin_layout Plain Layout
M-HANDLED, 1
\end_layout

\begin_layout Plain Layout
M-FATAL, 2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Objects trying to handle actions may need to double check which object is
 the direct and indirect object.
 In an example from Infocom:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

TAKE SWORD FROM THE STONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would have the STONE object process the TAKE action first.
 In that case, the STONE could interpret the user trying to take the STONE.
 To prevent this, STONE object could see if it is the PRSI before handling
 the action.
\end_layout

\begin_layout Standard
Later ZIP 3 games also included checking an object’s CONTFCN (container
 function) before having the direct object try to handle the action.
 This was only called in those rare situations (such as in 
\series bold
Starcross
\series default
) where the direct object’s container would try to handle an action.
\end_layout

\begin_layout Subsection
THIS-IS-IT
\end_layout

\begin_layout Standard
Starting with 
\series bold
Sorcerer
\series default
, PERFORM calls THIS-IS-IT after acting upon the PRSO and PRSI to update
 the IT-OBJECT.
 The PRSO value is stored as the IT-OBJECT value.
 
\series bold
Planetfall
\series default
 would introduce saving the location of the IT-OBJECT as well in a separate
 global variable.
 
\series bold
Wishbringer
\series default
 added other pronouns objects (HIM-OBJECT, HER-OBJECT, and THEM-OBJECT)
 along with their associated global variables which would be updated if
 needed based upon the attributes of the PRSO (such as gender or being plural).
 The routine is also called from other parts of the game like ITAKE-CHECK
 and specific action routines.
 It was only used in 
\series bold
LGOP
\series default
, 
\series bold
Moonmist
\series default
, 
\series bold
Hollywood Hijinx
\series default
, 
\series bold
Stationfall
\series default
, and 
\series bold
Plundered Hearts
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Pardon the Interruptions
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
An interrupt is a special routine that is called after a certain number
 of turns has lapsed.
 They can be used to monitor objects and variables in the background.
 Interrupts will then change other variables and objects or call other routines
 and actions.
 Naming of these interrupt routines is done by adding a “I-” prefix to the
 routine name.
 The array to hold interrupt entries is a 180 byte (90 word) table where
 each entry had 3 words: enable flag, number of turns (TICKS), and routine
 address.
 This meant the table could only hold 30 entries.
 Only 3 routines are used to manage this ingenious system: INT to create
 or retrieve interrupt entries, QUEUE to set the number of turns before
 the interrupt is called, and CLOCKER which checks all the interrupts and
 finds those that need to be executed.
\end_layout

\begin_layout Standard
One thing to note is that there is no way to delete or replace an interrupt
 entry.
 It can be disabled by clearing the enable flag though.
 So there is a limited number of total interrupts that can be created.
\end_layout

\begin_layout Subsection
Creating and Storing interrupts with INT
\end_layout

\begin_layout Description
Arguments: Routine address
\end_layout

\begin_layout Description
Returns: Address to interrupt entry
\end_layout

\begin_layout Standard
INT typically uses the 180 byte interrupt table to manage up to 30 interrupt
 entries.
 Some games like 
\series bold
Deadline
\series default
 and 
\series bold
The Witness
\series default
 use 300 bytes while 
\series bold
Cutthroats
\series default
’s table was 246 bytes in size.
 The table is filled like a stack, from the highest address to the lowest.
 So the oldest routines are located in the higher address, or the bottom
 of the table.
 The pointer to the newest interrupt entry (C-INTS) then moves toward the
 front of the buffer.
 After a routine address is passed to INT,
\end_layout

\begin_layout Itemize
The routine address in each entry in the interrupt table is checked (starting
 with the newest entry) with the requested one until there is a match or
 no more entries exist (when the pointer to the current entry reaches the
 end of the table).
\end_layout

\begin_layout Itemize
If there is a match, then the address to this interrupt entry is returned.
\end_layout

\begin_layout Itemize
If there is no match, then pointer to the newest entry is moved up (decrease
 by 6 bytes) and now points to a new blank entry.
 The requested routine address is stored in the appropriate location in
 the new entry.
 The address to this new entry is returned.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/Interrupts.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Interrupts
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
QUEUE - Setting Up the Interrupts
\end_layout

\begin_layout Description
Arguments: Routine address, Number of turns
\end_layout

\begin_layout Description
Returns: Address of interrupt entry
\end_layout

\begin_layout Standard
With the first generation interrupt routines, QUEUE was a separate routine
 to set the number of turns, or TICKS.
 It would call INT to get the address to the interrupt entry for the request
 routine address (creating the entry if necessary).
 Then.
 it would store the number of ticks for that interrupt in the 2nd word value
 of that entry and return the address to this interrupt entry.
 The setting of the enable flag was not done and have to be done using a
 separate STORE command.
 The last few ZIP 3 games (
\series bold
Stationfall
\series default
 and 
\series bold
The Lurking Horror
\series default
) and most EZIP games (all except 
\series bold
AMFV
\series default
) and all XZIP games did not use QUEUE.
 INT would automatically queue those entries or the games would do it without
 a separate routine.
\end_layout

\begin_layout Subsection
CLOCKER - Running Interrupts
\end_layout

\begin_layout Description
Arguments: None
\end_layout

\begin_layout Description
Returns: TRUE if an interrupt was executed, FALSE if no interrupt was executed
\end_layout

\begin_layout Standard
CLOCKER is the main routine that checks each interrupt entry and decreases
 the number of turns for any enabled entry.
 It will call the routine at the address stored in any interrupt entry with
 only 1 TICK left or -1 TICKS which indicates the entry will always be executed.
 CLOCKER is always called at the end of the MAIN-LOOP.
\end_layout

\begin_layout Itemize
If the given command was valid, CLOCKER will search through the interrupt
 table for entries with their enable flag set and extract the number of
 turns left.
\end_layout

\begin_deeper
\begin_layout Itemize
The search begins with the newest interrupt entry and proceeds to the oldest
 entry.
\end_layout

\end_deeper
\begin_layout Itemize
If the TICKS is zero, CLOCKER goes to the next entry.
\end_layout

\begin_layout Itemize
If the TICKS is not zero (a negative, 1, or greater than 1) then it will
 be decreased by 1 and saved back into the entry.
\end_layout

\begin_layout Itemize
If the TICKS is still greater than 1, then CLOCKER will then go to the next
 entry.
\end_layout

\begin_layout Itemize
At this point, CLOCKER will call the routine at the addr stored in the interrupt
 entry.
 TICKS will be 1 or a negative number at this point.
\end_layout

\begin_layout Standard
If no routine is called, CLOCKER will return FALSE.
 Otherwise, it will return TRUE no matter how many routines are called.
 The actual return value of the routine is not returned.
\end_layout

\begin_layout Subsection
What about DEMONs?
\end_layout

\begin_layout Standard
INT allowed an initially set of interrupts to be added to the interrupt
 table that are always checked regardless of the PARSER outcome.
 This is marked by by the C-DEMONS pointer which moves from the end of the
 interrupt table when new entries are created with the DEMON flag set.
 C-INTS also moves when an entry is added when the DEMON flag is set.
 In game design, these important interrupts are added first and end up at
 the bottom of the interrupt table.
 All other interrupts but be added above these entries.
 If PARSER fails on a given command, CLOCKER will this and start checking
 the interrupts starting with C-DEMON and not C-INT.
\end_layout

\begin_layout Standard

\series bold
Zork 1
\series default
’s first use of these special, all-run, interrupts were used for the demons
 and monsters in the game.
 This term is very similar to “daemons” in operating systems where background
 processes can run on their own.
 However, Infocom’s use of the word “demon” came after “daemon” was already
 used by other programmers.
 It is probably just a happy coincidence.
\end_layout

\begin_layout Subsection
Update: New INT and Interrupt Entry
\end_layout

\begin_layout Standard
All of the ZIP 1 and 2 games and most of the ZIP 3 games use the same INT
 routine as seen in Zork 1.
 
\series bold
Cutthroats
\series default
, 
\series bold
HGTG
\series default
, and 
\series bold
Suspect
\series default
 used a slightly modified INT where DEMON pointer is omitted.
 The first major change was with 
\series bold
AMFV
\series default
 where the size of the interrupt entry shrank to 2 words by removing the
 ENABLE flag.
 Now, each entry with non-zero TICKS is considered enabled.
 Most of the ZIP 3 games since 
\series bold
LGOP
\series default
 also used this more compact interrupt entry structure.
 
\series bold
AMFV
\series default
’s version also kept track of the most recent blank entry which would be
 used when storing a new entry instead of creating a new one.
 If new entry needs to be created beyond the limits of the table, an error
 message is displayed but the entry is still created.
\end_layout

\begin_layout Standard

\series bold
LGOP
\series default
 also introduced a smarter INT routine that build off the one from 
\series bold
AMFV
\series default
.
 It would “remove” any entries at the top of the table with no more TICKS
 left by moving C-INT and skipping over these completed entries.
 Any entries with no more TICKS surrounded by entries that were still enable
 were not removed.
 This smarter INT also modified how interrupts during the game initialization
 are stored.
 It would convert their TICK numbers (by increasing it by 3 and making it
 negative) to label these interrupts so they would not be called until CLOCKER
 had already been executed.
 So, the first call of CLOCKER would convert these entries back to normal
 entries (converting the TICKS back to positive values and subtracting 3)
 and then be checked on the next call to CLOCKER.
 So, these initial interrupts would be bypassed at the start.
\end_layout

\begin_layout Standard
Only a few subsequent Infocom games modified their INT routines beyond what
 was mentioned.
 A few added special flag checks that would quit out of INT.
 
\series bold
Borderzone
\series default
 and 
\series bold
Sherlock
\series default
 both used time more than ticks and had modified INT routines to reflect
 that.
 
\end_layout

\begin_layout Subsection
Update: New CLOCKER
\end_layout

\begin_layout Standard
CLOCKER also went through multiple modifications over successive games.
 The ZIP 2 version added the CLOCK-WAIT flag which skips checking any interrupts
 (including DEMON ones) when set and is cleared.
 This feature is only important for the WAIT command which already calls
 CLOCKER 3 times by default.
 Without this flag, the MAIN-LOOP will also call CLOCKER after WAIT is completed.
 So there would be 4 calls to CLOCKER for a WAIT command which is seen in
 ZIP 1.
 So the flag helps clear up that confusion.
\end_layout

\begin_layout Standard
Some CLOCKER routines (like in 
\series bold
Deadline
\series default
, 
\series bold
Trinity
\series default
, 
\series bold
Bureaucracy
\series default
, 
\series bold
Borderzone
\series default
, and 
\series bold
Sherlock
\series default
) would also increment separate time variables (seconds, minutes, hours,
 and possibly days) that the game would use for various situations.
 These routines (like in 
\series bold
Deadline
\series default
 and 
\series bold
Moonmist
\series default
) check the number of turns or the elapsed time to see if the game should
 end prematurely or reset specific counters.
 Others like Wishbringer would check specific flags that would cause CLOCKER
 to execute routines of specific entries if their TICK values were below
 a certain threshold.
 Later versions (
\series bold
Suspended
\series default
, 
\series bold
Infidel
\series default
, 
\series bold
Enchanter
\series default
, 
\series bold
Zork 1
\series default
, 
\series bold
Zork 2
\series default
, 
\series bold
Sorcerer
\series default
, 
\series bold
Moonmist
\series default
, 
\series bold
Ballyhoo
\series default
, 
\series bold
Mini-Zork
\series default
) increase the number of turns in CLOCKER instead of MAIN-LOOP.
 
\series bold
The Witness
\series default
, 
\series bold
Seastalker
\series default
, and 
\series bold
Cutthroats
\series default
 return the first non-zero interrupt routine result.
 However, if one of the routine returns M-FATAL, then that will always be
 returned.
\end_layout

\begin_layout Standard

\series bold
Planetfall
\series default
 corrected one logic error in the original INT routine regarding entries
 with negative TICKS.
 Previously, any entry with a negative TICK value would have its routine
 execute with the TICK value decreasing as well.
 So subsequent calls to this entry would make the TICK value more negative.
 Theoretically, that value could then flip into the positive range because
 of the way negative numbers are represented.
 Hexidecimal values of $0001 to $7FFF are positive (1 to 32767) while $8000
 to $FFFF are negative (-32768 to -1).
 If a TICK value of $8000 (-32768) is decreased by 1 again, the new value
 $7FFF now is 32767 and will not be executed on the next CLOCKER cycle.
 
\series bold
Planetfall
\series default
 added a specific check for the $FFFF (-1) TICK value which would still
 execute the routine at the entry’s address but would not decrease the TICK
 value.
\end_layout

\begin_layout Standard
As mentioned before, 
\series bold
AMFV
\series default
 uses the shortened 2 word entry.
 Its CLOCKER also will clear out the routine address of any entry that also
 has zero TICKS.
 This allows INT to use these blank entries for new entries.
 
\series bold
LGOP
\series default
’s CLOCKER had the ability to “delete” entries that were at the top of the
 interrupt table.
 It would lower the starting point of the interrupt table to just past any
 blank or recently completed entries.
 If any blank or completed entries were below a still enabled entry, they
 could not be deleted.
 
\series bold
Stationfall
\series default
 and 
\series bold
Sherlock
\series default
 could decreased TICKS/time value by a different amount for all entries
 with each call of CLOCKER.
 This allowed parts of the game to cause interrupts to be executed soon
 than expected as each call of CLOCKER will more rapidly drop the TICK counts.
\end_layout

\begin_layout Standard

\series bold
HGTG
\series default
 still has the PARSER valid check to decide which pointer to use.
 If the PARSER fails, the entire table is checked (#00 as pointer) instead
 of from the newest entry.
\end_layout

\begin_layout Subsection
Removing Interrupts with DEQUEUE
\end_layout

\begin_layout Description
Arguments: Routine address
\end_layout

\begin_layout Description
Return: TRUE if successful, FALSE if unable to find interrupt
\end_layout

\begin_layout Standard
DEQUEUE was introduced in LGOP and clears the routine address of the entry
 with that address.
 Any dequeued entry would eventually be “removed” by CLOCKER.
\end_layout

\begin_layout Subsection
New Predicates for the Interrupts
\end_layout

\begin_layout Standard
ENABLED?
\end_layout

\begin_layout Description
Arguments: Routine address
\end_layout

\begin_layout Description
Return: TRUE if matching interrupt is enabled, FALSE if no match found or
 interrupt is not enabled
\end_layout

\begin_layout Standard
RUNNING?
\end_layout

\begin_layout Description
Arguments: Routine address
\end_layout

\begin_layout Description
Return: TRUE if matching interrupt has at least 1 TICK left, FALSE if no
 TICKS left or no match found
\end_layout

\begin_layout Standard
Two new predicates were added, ENABLED? And RUNNING? in 
\series bold
Cutthroats
\series default
 to help find the status of specific interrupts.
 ENABLED? returned TRUE if the ENABLED word in a matching interrupt entry
 was set.
 RUNNING? returned TRUE if the TICKS in a matching entry was not zero, including
 -1.
 In 
\series bold
LGOP
\series default
, ENABLED? was changed as no ENABLED word exists in its entries.
 It would check the TICKS value and return TRUE if it was non-zero including
 -1.
 
\series bold
LGOP
\series default
’s version of RUNNING? would return TRUE if the matching entry’s TICK value
 was 1 or -1.
 So only entries that will be executed on the next call of CLOCKER are considere
d running.
\end_layout

\begin_layout Section
Basic Screen Output and TELL
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Infocom strived for readability, natural feel, and varied responses of its
 games with its text routines.
 The games tried to be grammatically correct with display articles before
 nouns and using plural forms if necessary.
 Later games would fine tune these routines even more.
 Infocom did use programming macros for creating the proper text display
 routines.
 These macros would then be expanded into the proper ZIL code during compiling.
 It is difficult to figure out which was the first game to use this without
 the source code.
 The macros are seen in the 
\series bold
Mini-Zork
\series default
 source code.
\end_layout

\begin_layout Subsection
Abbreviations / Frequent words table
\end_layout

\begin_layout Standard
Starting with ZIP version 2, Infocom games used abbreviations to help reduce
 the space taken up by text.
 In version 2, the ZSCII character $01 signaled an abbreviation is to be
 display.The next ZSCII character indicates the requested abbreviation.
 This allows for 32 abbreviations.
 The abbreviation ZSCII character is consistent throughout the 3 character
 sets.
 The previous new-line control character (ZSCII 1) was moved to ZSCII 7
 in character set 2.
\end_layout

\begin_layout Standard
To allow for more abbreviations, ZIP versions 3 and higher also use characters
 $02 and $03 to signal an abbreviation.
 Since each of these special control characters can access 32 abbreviations,
 these games could have 96 abbreviation, calculated using the formation:
 (abbreviation character value - 1) * 32 + next character’s ZSCII value.
 This also left only 2 control characters (ZSCII 4 and 5) remain to change
 the character set.
 Those control characters were repurposed to change the character set for
 next character only.
 There would be no “shift lock”.
\end_layout

\begin_layout Standard
An abbreviation table contains 32 (or 96 for versions 3 or higher) word
 addresses for the Z-strings.
 The abbreviation and next characters will then point to an entry in this
 abbreviation table with an address to a Z-string which will then be displayed.
 Because each abbreviation uses 2 characters, abbreviations for string longer
 than 2 characters could help reduce the size of the story file.
\end_layout

\begin_layout Subsection
Special PRINT Routines - WORD-PRINT, CLAUSE-PRINT, PREP-PRINT
\end_layout

\begin_layout Standard

\series bold
Zork 1
\series default
 also included three print routines that work with the given command and
 prepositions:
\end_layout

\begin_layout Itemize
WORD-PRINT
\end_layout

\begin_layout Itemize
PREP-PRINT
\end_layout

\begin_layout Itemize
CLAUSE-PRINT
\end_layout

\begin_layout Standard
WORD-PRINT displays a sequence of characters from INBUF given the starting
 character and number of characters to print.
\end_layout

\begin_layout Standard
PREP-PRINT displays the preposition given the preposition byte number,.
 The routine uses PREP-FIND to convert the preposition byte number to a
 Vocabulary address for the preposition.
 The only except is “through” which is larger than the 6 character limit
 for ZIP 3 or earlier.
 PREP-PRINT looks for the corresponding preposition number and just display
 the entire token.
\end_layout

\begin_layout Standard
CLAUSE-PRINT display the entire noun clause using the boundary addresses
 stored in ITBL.
 A preceding preposition can also be displayed if the preposition number
 is also passed as an argument.
 The boundary addresses to use are based upon the element numbers in ITBL.
 Displaying the token from Vocabulary or from INBUF depends on state of
 O-FLAG.
 The routine will use strings from the Vocabulary (maximum of 6 characters)
 if the O-FLAG is set.
 Otherwise, it will use WORD-PRINT to print the entire token from INBUF.
 
\end_layout

\begin_layout Standard
display the tokens in LEXV given by the start and end address of the requested
 noun clause.
 This limited any token to 6 characters.
 If the O-FLAG was clear, the routine extracted the length and location
 of each token in INBUF and displayed the complete token.
\end_layout

\begin_layout Subsection
New versions PRINT routines
\end_layout

\begin_layout Standard
Deadline introduced several 4 new routines and updated CLAUSE-PRINT to improve
 the quality of the displayed text.
\end_layout

\begin_layout Standard
BUFFER-PRINT is a new routine that displays a sequence of tokens while modifying
 any truncated or referred tokens.
 For example, the “mrs” token will then be displayed as “mrs.” while the
 “it” token is replaced with its referring object.
 The address of the starting token and token after the last one to display
 are passed to the routine.
 The fourth argument is a boolean value to indicate print a preceding space
 before the first and subsequent tokens.
\end_layout

\begin_layout Standard
PRSO-PRINT and PRSI-PRINT are new routines that will display the direct
 or indirect object clause, respectively.
 They extract the starting and ending addresses of the clause from ITBL
 and see if the first token in the clause is “it”.
 If so, the current PRSO is displayed.
 Otherwise, these addresses are passed to BUFFER-PRINT.
\end_layout

\begin_layout Standard
The last new routine display a token with the first letter capitalized.
 No official name is known but could be called CAPITALIZE-PRINT.
 The routine pulls the first character and converts it to uppercase without
 checking the case first.
 Then it will use WORD-PRINT to display the remaining part of the token.
\end_layout

\begin_layout Standard
The new CLAUSE-PRINT utilizes BUFFER-PRINT to display those representative
 tokens with their proper names.
 The routine will take the start and end element numbers from ITBL and extracts
 the start and end addresses for the tokens to print.
 These are then sent to BUFFER-PRINT.
\end_layout

\begin_layout Standard
Enchanter would later introduce THING-PRINT which takes a boolean argument
 to choose which object clause to use (true for direct, false for indirect).
 The routine pulls the start and end addresses for the requested object
 clause and passes it to BUFFER-PRINT.
\end_layout

\begin_layout Subsection
Error message routines
\end_layout

\begin_layout Standard
All Infocom games have several default error messages when handling errors
 with given commands.
\end_layout

\begin_layout Itemize
CANT-USE
\end_layout

\begin_layout Itemize
CANT-ORPHAN
\end_layout

\begin_layout Itemize
UNKNOWN-WORD
\end_layout

\begin_layout Standard
CANT-USE was first used in 
\series bold
Deadline
\series default
 and would insert an invalid token into the phrase: The word ‘<word>’ can’t
 be used in that sense.
\end_layout

\begin_layout Standard
CANT-OPRHAN was added in Starcross and had the static message: That command
 was incomplete.
 Why don't you try again?
\end_layout

\begin_layout Standard
UNKNOWN-WORD would display the word that is not found in Vocabulary:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

[I don't know the word "<word>
\begin_inset Quotes erd
\end_inset

 in a way that I don't understand.]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and also updates the OOPS-TABLE with the location of the token that is unrecogni
zed.
\end_layout

\begin_layout Subsection
Using the TELL Macro
\end_layout

\begin_layout Standard
Source code for Infocom games used macros where a specific keyword and associate
d data would be replaced with code incorporating that extra data.
 TELL was the universal way of displaying text.
 However, this could result in repetitive code to display the same kind
 of text.
 So, later design guides for Infocom games describes the use of the TELL
 macro with multiple modifiers.
 But, the macros would not be replaced with strings of ZIL code but a call
 to separate routines for displaying text with any additional modifiers
 such as proper definite and indefinite articles (depending on the type
 and number of the object) or ending periods and linefeeds.
 “Learning ZIL” describes these modifiers.
 
\end_layout

\begin_layout Section
The Describers - For Rooms and Objects
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
There are several routines in an Infocom games that specialize in describing
 locations and objects which are an essential part of any game.
 “Learning ZIL” mentions DESCRIBE-ROOM and DESCRIBE-OBJECTS, but there are
 also DESCRIBE-OBJECT, PRINT-CONT, and later PRINT-CONTENTS which complete
 the needed routines to display an object and its contents.
 For example, LOOK would call DESCRIBE-ROOM and DESCRIBE-OBJECTS with the
 verbose argument set.
 Other commands, like INVENTORY or LOOK-INSIDE, would call PRINT-CONT on
 the WINNER or PRSO, respectively.
\end_layout

\begin_layout Subsection
PRINT-CONT
\end_layout

\begin_layout Description
Arguments: Object or Room number, Verbose flag, LEVEL number
\end_layout

\begin_layout Description
Returns: TRUE if there is some descriptive output, FALSE if none given
\end_layout

\begin_layout Standard
PRINT-CONT will describe the contents of the objects contained in the given
 object or room.
 The routine will first describe each object by display the string in the
 FDESC (First DESCription) property of the object.
 Any object that also can be seen inside (using SEE-INSIDE? predicate) will
 have PRINT-CONT recursively called on it.
 If the routine is being used to display the inventory of the WINNER’s possessio
n, it will skip the display of the FDESC’s of all the objects.
 PRINT-CONT will then see if a special header (such as “You are carrying:”
 or “The <object> contains: “) needs to be displayed by seeing.
 This is done when an inventory is requested or the objects have already
 been “touched”.
 This also needs to be the first text displayed for that particular routine
 call.
 PRINT-CONT will then call DESCRIBE-OBJECT on each object to have it described.
 If any of these objects are an integral part of another object, then PRINT-CONT
 is called recursively on this integral object to see if anything else can
 be described.
 Once all the objects are checked again, PRINT-CONT will also see if the
 WINNER is in a vehicle and if that vehicle is part of the contents of the
 original requested object.
 If so, then PRINT-CONT will be called on that vehicle.
 While a verbose flag argument can be passed, it is never used.
 The LEVEL argument determines the indent of the descriptive text uses spaces
 from the IDENTS table (maximum of 5).
 As the routine does further recursion, the level number increases along
 with the corresponding indent.
\end_layout

\begin_layout Subsection
DESCRIBE-OBJECT
\end_layout

\begin_layout Description
Arguments: Object or Room number, Verbose flag, LEVEL number
\end_layout

\begin_layout Description
Returns: TRUE if extra descriptive output given from internal objects, FALSE
 if none given
\end_layout

\begin_layout Standard
DESCRIBE-OBJECT will try to display a descriptive text about an object using
 the FDESC (if the object is untouched) or LDESC.
 If neither is available, a generic description is given, “There is a” for
 level 0 or “A” for all other levels.
 If the WINNER is also in a vehicle, then a clarifying “(in the room)” is
 given to remind the WINNER that the object is NOT in the vehicle.
 Also any objects that have visible contents will be also called with PRINT-CONT
 to display the contents of that object.
 Againa, the Verbose flag is not used in the routine but passed to PRINT-CONT
 if it is called.
\end_layout

\begin_layout Subsection
DESCRIBE-OBJECTS
\end_layout

\begin_layout Description
Arguments: Verbose flag
\end_layout

\begin_layout Description
Returns: TRUE if there is some descriptive output, FALSE if none given
\end_layout

\begin_layout Standard
DESCRIBE-OBJECTS will try to display a descriptive text for all the objects
 in the current location (HERE).
 It will not display a description of the location itself.
 If that location is not lit, the routine will return with the error message
 “I can’t see anything in the dark.” If any objects do exist in the current
 location, DESCRIBE-OBJECTS will call PRINT-CONT with this location and
 the current VERBOSE level if one is not given.
 Return values are the same as PRINT-CONT.
\end_layout

\begin_layout Subsection
DESCRIBE-ROOM
\end_layout

\begin_layout Description
Arguments: TRUE (if called by LOOK action)
\end_layout

\begin_layout Description
Returns: TRUE if room description given, FALSE if too dark to give description
\end_layout

\begin_layout Standard
DESCRIBE-ROOM will initially check if the room is dark, displaying a too-dark
 error message if it is.
 The routine will then display the room name and decide if a further description
s should be given.
 If it was not called by a LOOK command or SUPERBRIEF is SET, then no further
 description is given.
 If the WINNER is in a vehicle which is also in the room, the routine will
 indicate that with the clarifying “(You are in the <vehicle>.)”.
 DESCRIBE-ROOM will then check if the Verbose flag is set, or the room is
 untouched.
 Either situation would have the routine try to call the room’s ACTION routine
 with M-LOOK to provide a description.
 If this fails, the room’s LDESC string will be used if possible.
 If a room is untouched, then that room’s TOUCHBIT will be set.
\end_layout

\begin_layout Subsection
PRINT-CONTENTS
\end_layout

\begin_layout Description
Arguments: Object number
\end_layout

\begin_layout Description
Returns: TRUE
\end_layout

\begin_layout Standard
PRINT-CONTENTS was added with 
\series bold
Sorcerer-R6
\series default
 to quickly display a list of objects in a room or container.
 The object names would be separated by commas and “and”, if necessary.
 If only one object was listed, then IT-OBJECT would be updated with that
 object.
\end_layout

\begin_layout Subsection
Update: DESCRIBE-ROOM
\end_layout

\begin_layout Standard

\series bold
Zork 2
\series default
 added a new RARG (M-FLASH or $04) on a room’s ACTION routine even if verbose
 is clear (minimal output).
 This allows a room to display important information even if the room was
 already touched or verbose is clear.
 It also added a final call to the WINNER’s vehicle’s ACTION with M-LOOK
 (if in a vehicle) when describing the current location.
\end_layout

\begin_layout Section
Common Routines and Predicates
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Numerous routines are found in most or all Infocom games and provide important
 functions that are not specific to a certain game or action.
 Predicates are a special type of routines that return true or false based
 upon the given arguments.
 “Learning ZIL” does give numerous examples.
 No systematic search has been made to find all of these special routines
 found in all Infocom games.
 The known ones can be divided into four main categories:
\end_layout

\begin_layout Itemize
Tables
\end_layout

\begin_layout Itemize
Objects
\end_layout

\begin_layout Itemize
Game States
\end_layout

\begin_layout Itemize
Movements
\end_layout

\begin_layout Subsection
Table Routines and Predicates
\end_layout

\begin_layout Standard
There are three common table routines used in Infocom games since Zork 1:
\end_layout

\begin_layout Itemize
ZMEMQB (byte, address to table)
\end_layout

\begin_layout Itemize
ZMEMQ (word, address to table, last element to check, first element to check)
\end_layout

\begin_layout Itemize
PICK-ONE (address to table)
\end_layout

\begin_layout Standard
ZMEMQB searches for a given byte in a table of bytes.
 The interested byte and table are passed as arguments.
 After getting the number of items in the table, the routine will step through
 each byte.
 If the given byte is found, it returns true.
 Otherwise, it will return false.
\end_layout

\begin_layout Standard
ZMEMQ is similar to ZMEMQ but searches for a specific word in a table of
 word up to the last element indicated.
 It also accepts one additional argument: first element number to check.
 If this argument is not gien, then it will use the beginning of the table.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

ZMEMQ(0x3EA0, TBL, 6, 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would search for the word 0x3EA0 in a table of words starting with elements
 2 through 6.
\end_layout

\begin_layout Standard
PICK-ONE, the original version, uses a table of words where one of these
 elements is randomly picked and returned.
 The new PICK-ONE keeps track of what elements have already been picked
 and will not pick them again until all the others have been picked.
 This is accomplished by “sorting” the table of elements.
 Any picked word is swapped with the first unpicked word.
 When only 0 unpicked words remain, the number of picked elements is reset
 which causes the entire process to be repeated.
 It is quite ingenious.
\end_layout

\begin_layout Enumerate
Get total number entries (0th word) and number of previously picked string
 address (1st word) of string address in the table
\end_layout

\begin_layout Enumerate
Decrease total number of entries by 1 as one of the entries is the number
 of picked string addresses
\end_layout

\begin_layout Enumerate
Calculate the address of the first unpicked string address and number of
 unpicked string addresses
\end_layout

\begin_layout Enumerate
Random pick a number with maximum number being the number of unpicked string
 addresses
\end_layout

\begin_layout Enumerate
Get the string address at that random location
\end_layout

\begin_layout Enumerate
Swap that string address with the one located in the first original unpicked
 string addresses group
\end_layout

\begin_layout Enumerate
Update the number of picked items (1st word in the table)
\end_layout

\begin_layout Enumerate
If all the items have been picked (number of picked items equal total number
 of available address), then reset this value to zero.
\end_layout

\begin_layout Standard
The picked word is then returned.
 Some games use both PICK-ONE returns as different situations can demand
 different versions of the routine.
\end_layout

\begin_layout Subsection
Object Predicates
\end_layout

\begin_layout Standard
As for the predicates, these will see if a given object can be interacted
 with in specific ways.
\end_layout

\begin_layout Itemize
LIT?
\end_layout

\begin_layout Itemize
HELD?
\end_layout

\begin_layout Itemize
SEE-INSIDE?
\end_layout

\begin_layout Itemize
ACCESSIBLE?
\end_layout

\begin_layout Itemize
VISIBLE?
\end_layout

\begin_layout Itemize
UNTOUCHABLE?
\end_layout

\begin_layout Itemize
GLOBAL-IN?
\end_layout

\begin_layout Itemize
TOUCHING? (not used)
\end_layout

\begin_layout Standard
LIT? is the main predicate in 
\series bold
Zork 1
\series default
.
 It checks if the WINNER can see around in a given location by looking at
 the ONBIT attribute.
 If the ONBIT is clear (location is dark), the routine will do a secondary
 check if the given location is the same as the WINNER’s location.
 The secondary check will look for any objects in the given location.
 If any are found, then the location is considered lit and the routine will
 return TRUE.
\end_layout

\begin_layout Standard
HELD? is also in 
\series bold
Zork 1
\series default
 and checks the location of the given object’s location.
 If it is not the WINNER, this location replaces the given object and the
 routine loops back to get the new location of the just found location.
 This continues until the location is the WINNER (return TRUE) or the location
 of the object is blank (return FALSE).
 Other versions such as in 
\series bold
Zork 3
\series default
 uses a recursive method to find the ultimate location of an object and
 also look for the ROOMS and GLOBAL objects which result in a false response.
 
\series bold
HGTG
\series default
 introduced a second argument which was a room or object.
 This would be used instead of the WINNER to determine if the given object
 was ultimately located in it.
 If no second argument was given, the routine would check if the given object
 was inside the WINNER.
\end_layout

\begin_layout Standard
SEE-INSIDE? checks for specific attributes on a given object to see if its
 contents are visible.
 This applies to containers such as a box or a surface object like a table
 where objects can be placed on it.
 The routine was first used with 
\series bold
Sorcerer
\series default
 and checked three attributes: INVISIBLE, OPEN, and TRANSPARENT.
 The contents of an invisible object cannot be seen.
 An object that is open or transparent can have its content seen from the
 outside.
 
\series bold
Wishbringer
\series default
 added an initial check to see if the object is a surface which always leads
 to a true response.
 If object was not a surface, open, or transparent, the routine would check
 if the object is an Actor and not the WINNER.
 Objects contained in an actor are always visible.
 
\series bold
Hollywood Hijinx
\series default
 would check if the given object was a container.
 If it is false, then the routine jumps to the section to check if the given
 object is an Actor.
\end_layout

\begin_layout Standard
ACCESSIBLE? was first introduced in 
\series bold
Zork 3
\series default
 and checks if the given object can be used.
 There are objects that are visible but cannot be used (an object inside
 a closed and transparent container).
 It would return true if the given object was present in the current location
 or is one of the game’s GLOBAL objects.
\end_layout

\begin_layout Standard
VISIBLE? was also introduced in Sorcerer and sees if the given object can
 be used or seen by the WINNER.
 The routine checks if the given object is accessible using the ACCESSIBLE?
 predicate.
 If that is false, the routine checks if the WINNER can see inside the given
 object’s location (for example if it is in a clear box) by using SEE-INSIDE?
 If that is true, the routine will then recursively call VISIBLE? with the
 object’s location.
 Wishbringer used a slightly different approach with checking to see if
 the object was invisible first.
 If not, the location of the object is found with META-LOC (a room or GLOBAL
 object).
 If it is on the WINNER, in the current room, or a GLOBAL object, then it
 is considered visible.
 If the object is located somewhere else, the routine calls ACCESSIBLE?
 to see if it is accessible.
 If so, then consider it visible.
 Sherlock only uses a single modified ACCESSIBLE? command that also calls
 a modified SEE-INSIDE? routine.
 So this mimics the original form.
\end_layout

\begin_layout Standard
UNTOUCHABLE? is a curious predicate that seems to be only used in 
\series bold
LGOP
\series default
 to screen for various special situations where objects are in the same
 room but cannot be touched.
 For example, an object inside of inside of a cage that is also in the room
 with the WINNER is considered untouchable.
 If the given object is in the current location, held by the WINNER, or
 contained inside the WINNER, then it would return FALSE (ie.
 it is touchable).
 
\end_layout

\begin_layout Standard
GLOBAL-IN? is a simple predicate that takes two arguments, an object and
 location, and checks if the object is a local-global for that location.
 Essentially, the routine uses the ZMEMQB or SCAN_TABLE opcode to look for
 the given object in the GLOBAL property of the location.
\end_layout

\begin_layout Standard
TOUCHING? is described in “Learning ZIL” as a predicate that takes an object
 and sees if it needs to be “touched” to perform the current action, PRSA.
 There is no evidence in any released game of a separate predicate that
 performs this function.
 Many action routines do a similar type of check, however.
\end_layout

\begin_layout Subsection
Object Routines
\end_layout

\begin_layout Standard
The most common set of routines relate to objects.
 These include routines and predicates.
 The routines return specific values:
\end_layout

\begin_layout Itemize
ROB
\end_layout

\begin_layout Itemize
WEIGHT
\end_layout

\begin_layout Itemize
META-LOC
\end_layout

\begin_layout Itemize
FIND-IN
\end_layout

\begin_layout Standard
Another routine CCOUNT (container count) and REMOVE-CAREFULLY are described
 in 
\series bold
Mini-Zork
\series default
 too.
\end_layout

\begin_layout Standard
ROB moves all the objects from one location (room or container) to another
 or empty destination.
 It will step through each object in one location and insert into another
 (or null) and then move to the next sibling object.
\end_layout

\begin_layout Standard
WEIGHT will add up the “weights” of all the objects in an object.
 This could be the PLAYER or a container.
 The routine goes through each child object in the given object.
 If the child object is a container, WEIGHT is called recursively on that
 child object.
 For each object, the weight property is read and added to the total for
 that object and returned.
 This routine is useful to see if the PLAYER or container cannot hold any
 more objects.
 The default weight for an object is set as one of the default property
 values for the object table.
\end_layout

\begin_layout Standard
Starting with 
\series bold
Zork 1
\series default
, META-LOC would originally find the room that an object is located.
 If the object was on the PLAYER or non-existent, it would return false.
 
\series bold
Starcross
\series default
 used different coding and also add defaulted to the “Bridge” for any non-attach
ed object.
 The Witness expanded the return values to also LOCAL-GLOBALS and GLOBALS
 objects.
\end_layout

\begin_layout Standard
FIND-IN will try to find an object in the given location with the given
 flag number set.
 It will return the first object found.
 If no object exists with that given flag set, FALSE is returned.
 “Learning ZIL” does mention that if more than one object has the given
 flag set, FIND-IN would also return false.
 However, there are no examples of a routine that keeps track of how many
 matches were found.
 All routines will exit after finding that first match.
 Some of the later games also except a string with the other arguments.
 This string will be displayed with the matched object name.
\end_layout

\begin_layout Standard
Two other routines in 
\series bold
Mini-Zork
\series default
 are not documented by “Learning ZIL”.
 CCOUNT will count the number of objects in the given location.
 It will not count any objects inside containers.
 REMOVE-CAREFULLY removes the given object unless “it” is given which clears
 out the IT-OBJECT variable.
 The routine then calls NOW-DARK?.
\end_layout

\begin_layout Subsection
Game State Routines and Predicates
\end_layout

\begin_layout Standard
Various routine will interact or change the different states in the game
 such as if the player is dead or reset the status line.
\end_layout

\begin_layout Itemize
JIGS-UP (string)
\end_layout

\begin_layout Itemize
INIT-STATUS-LINE (boolean ClearScreen?)
\end_layout

\begin_layout Itemize
UPDATE-STATUS-LINE
\end_layout

\begin_layout Itemize
NOW-DARK?
\end_layout

\begin_layout Itemize
NOW-LIT?
\end_layout

\begin_layout Itemize
VERB?
\end_layout

\begin_layout Itemize
GAME-VERB?
\end_layout

\begin_layout Standard
JIGS-UP is in every game in some fashion.
 It is called when the PLAYER is killed or the game is over.
 After the final score is displayed, a string is passed to it wish is displayed
 along with all the possible choices for the PLAYER to proceed such as restart
 the game or quit.
 If the game is restarted, the opcode RESTART is executed which will restart
 the interpreter and start execution with the GO routine.
\end_layout

\begin_layout Standard
The status line routines, INIT-STATUS-LINE and UPDATE-STATUS-LINE, are described
 in “Learning ZIL”as a common routine, but only 
\series bold
Sherlock
\series default
 seems to use it.
 Usually, the status line updates are handled by the routine for the READ
 opcode and is part of the Z-machine interpreter.
\end_layout

\begin_layout Standard
NOW-DARK? and NOW-LIT? are routines and not predicates.
 No arguments are passed to them.
 LGOP appears to be the first game that used these.
 However, there is little evidence that subsequent games incorporated this
 routine.
 NOW-DARK? sees if the current location is lit.
 If so, then it will clear the LIT global variable and provide a warning
 message.
 NOW-LIT? is the exact opposite except it will also call the V-LOOK routine
 after setting LIT.
\end_layout

\begin_layout Standard
VERB? is a predicate that returns TRUE if PRSA is equal to any of the given
 verbs in the predicate arguments.
 This does not actually call a routine but is expanded into a set of multiple
 commands based upon how many verbs are given.
\end_layout

\begin_layout Standard
GAME-VERB? is a simple predicate that checks if the current PRSA is one
 of the “game verbs” or a verb that does not trigger the CLOCKER routine.
 While “Learning ZIL” mentions a GAME-VERB list, it is unclear if this is
 a global list in ZIL or hard coded into the routine.
\end_layout

\begin_layout Subsection
Movement Routines
\end_layout

\begin_layout Standard
Since moving the PLAYER or actors is a very common action, Infocom games
 use three common routines to perform it:
\end_layout

\begin_layout Itemize
GOTO (room number)
\end_layout

\begin_layout Itemize
DO-WALK (direction)
\end_layout

\begin_layout Itemize
OTHER-SIDE
\end_layout

\begin_layout Standard
GOTO essentially moves the user to the requested location while still calling
 the destinations action routine with M-ENTER and getting a description.
 It does not check if the actor or WINNER is able to directly get to the
 location.
 Some people consider it like teleporting into a location.
\end_layout

\begin_layout Standard
DO-WALK is similar to GOTO but it uses PERFORM which performs all necessary
 checks (unlike GOTO).
 DO-WALK sets the direction of movement (P-WALK-DIR) and calls the V-WALK
 using PERFORM with that DIR.
\end_layout

\begin_layout Standard
OTHER-SIDE is given an object number of a door and returns the room number
 on the opposite side of the first door in the room.
 The routine steps through all the exit properties (highest to lowest) of
 the given room until it finds a door object (the property will be 5 bytes
 long).
 It the door object for that property matches the given door object, it
 will then return the room number associated with that exit.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Conclusion - The End
\end_layout

\begin_layout Standard
The creativity in designing the original ZORK on PDP main frame computer
 can be almost directly seen in the microprocessor version of all Infocom
 games.
 The structuring of rooms and objects, storing grammatical information,
 and the innovative parser led to a surprisingly complex and interactive
 game that could fit on a floppy disk.
 The use of a virtual Z-machine was the first known use of a virtualization
 in a home computer as well.
 A present day interactive fiction creator can now design their own games
 without having to start from scratch.
 But an ambitious programmer today can now use these essential data structures
 and routines to create their own fairly complex IF system if they want.
 While better game engines with more powerful parser and complex games already
 exist, the sophistication of these early text adventure games in just about
 60K of memory is a testament to all of the programmers’ skill with ZIL
 and the efficiency of Z-code.
 Hopefully, the information here has helped cracked the inner workings of
 these legendary games and made them more enjoyable and appreciated decades
 later.
\end_layout

\begin_layout Addsec
Appendix A: Story Headers
\end_layout

\begin_layout Subsection*
Header Layout
\end_layout

\begin_layout Subsubsection*
Original header layout found in all ZIP versions
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="65text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Word No.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZVERSION
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 0: Z-machine version
\end_layout

\begin_layout Plain Layout
Byte 1: Z-machine mode
\begin_inset Foot
status open

\begin_layout Plain Layout
Z-machine mode is described but never used (bit flags)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZORKID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Release number
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ENDLOD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End address of pre-loaded memory (code and data),
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Newline linebreak
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
Base of High Memory (start of non-preloaded data)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
03
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
START 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address of first instruction (not routine), Program Counter
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
04
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VOCAB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address to Vocabulary table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
05
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OBJECT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Object data address
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
06
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GLOBALS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address to Global Variable table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PURBOT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start address of read-only (static) memory, code and data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
08
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FLAGS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flags, 16 bits
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
ZIP version 2 added the abbreviation information
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="65text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
09-0B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SERIAL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bytes 12 to 17: Serial Number in ASCII characters (words also labeled as
 SERIAL, SERI1, and SERI2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FWORDS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address to Frequently used words (Abbreviation) table
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
ZIP version 3 added game information
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="65text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PLENTH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length of game file (shifted??)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PCHKSM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Checksum of game file
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
EZIP version extended story header layout
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="65text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INTWRD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 1E: INTID/Interpreter number
\begin_inset Newline linebreak
\end_inset

Byte 1F: INTVR/version
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SCRWRD
\begin_inset Foot
status open

\begin_layout Plain Layout
This word is set by the ZIP at startup.
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte 20: SCRV, Screen size in lines ($FF = printing terminal)
\begin_inset Newline linebreak
\end_inset

Byte 21: SCRH, Screen width in characters 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
XZIP also extended story header layout
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="65text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
11
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
HWRD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Screen horizontal size of display in pixels
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
VWRD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Screen vertical size of display in pixels
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FWRD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 26: Font height
\begin_inset Newline linebreak
\end_inset

Byte 27: Font width
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
LMRG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Screen left margin in pixels
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
RMRG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Screen right margin in pixels
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CLRWRD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 2C: Background color
\begin_inset Newline linebreak
\end_inset

Byte 2D: Foreground color
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TCHARS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Pointer to table of terminating characters
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CRCNT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Counter for carriage returns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CRFUNC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Function for carriage returns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CHRSET
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Pointer to character set table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
EXTAB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Pointer to extension table, if needed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1C-1F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
USRNM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Bytes 38 to 3F: Username in ASCII characters
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
MODE Byte
\end_layout

\begin_layout Standard
The MODE byte is the the second byte in the ZVERSION word of the story header.
 No bits are used in the Zork 1 and 2 games released by Infocom.
 Bits 0-1 are set by the ZAP assembler while bits 3 through 6 are set by
 the ZIP on startup.
\end_layout

\begin_layout Subsubsection*
Mode bits for ZIP version 3
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit No.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
byte-swap
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0 = high order byte first, 1 = low order byte first
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
status line format
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0 = score/turns, 1 = hours:minutes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
machine-specific function
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Story file split across two discs???
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Tandy bit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0 = non-Tandy, 1 = Tandy (to censor some informatino)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
status line existence
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0 = present, 1 = hiding
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
splitability
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0 = split screen functions ignored, 1 = split screen functions available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
reserved
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Default font is a Variable-width font???
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
reserved
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
????
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Mode bits for EZIP (ZIP version 4)
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit No.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EZIP Bit Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ESPLIT (screen operations)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SPLIT/SCREEN/CLEAR functions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
EHINV (highlight inverse)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Inverse highlight is not available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
EHBLD (highlight bold)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Bold highlight is not available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
EHUND (highlight underline-italics)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Underline-italic highlight not available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ECURS (cursor addressing)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CURSET/CURGET ignored
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ESOUN (SOUND opcode)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SOUND opcode is ignored
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Reserved
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Reserved
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
0 = not available/ignored, 1 = available
\end_layout

\begin_layout Subsubsection*
Mode bits for XZIP (ZIP version 5)
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit No.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
XCOLOR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
COLOR operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
XDISP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
DISPLAY (show images) operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
XBOLD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Bold
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
XUNDE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Italic/underline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
XMONO
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Monospace style font
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
XSOUN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SOUND
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Reserved
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Reserved
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
0 = not available/ignored, 1 = available
\end_layout

\begin_layout Subsubsection*
Extension table
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MSLOCX
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MSLOCY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MSETBL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MSEDIR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MSEINV
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MSEVRB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MSEWRD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
BUTTON
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
JOYSTICK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
BSTAT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 10
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
JSTAT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
word 11
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
writable
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
FLAGS Bits
\end_layout

\begin_layout Subsubsection*
FLAGS bits for ZIP
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit No.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Versions
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1-5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FSCRI
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Interpreter currently transcripting
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
3-4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FFIXE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Fixed-width font needed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
4-5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FSTAT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Refresh Status Line (by interpreter)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FDISP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
DISPLAY (show images) available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FUNDO
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
UNDO available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FMOUS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MOUSE available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FCOLO
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
COLOR available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
7-15
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1-5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Reserved
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
From E- and X-ZIP - Internal Infocom document
\end_layout

\begin_layout Addsec
Appendix B: Attributes and Properties From “Learning ZIL”
\end_layout

\begin_layout Subsection*
Object Attributes (through YZIP)
\end_layout

\begin_layout Description
TAKEBIT One of the most basic bits, this means that the player can pick
 up and carry the object.
\end_layout

\begin_layout Description
TRYTAKEBIT This bit tells the parser not to let the player implicitly take
 an object
\end_layout

\begin_layout Itemize
This is important if the object has a value and must be scored, or if the
 object has an NDESCBIT which must be cleared, or if you want taking the
 object to set a flag or queue a routine, or...
\end_layout

\begin_layout Description
CONTBIT The object is a container; things can be put inside it, it can be
 opened and closed, etc.
\end_layout

\begin_layout Description
DOORBIT The object is a door and various routines, such as V-OPEN, should
 treat it as such.
\end_layout

\begin_layout Description
OPENBIT The object is a door or container, and is open.
\end_layout

\begin_layout Description
SURFACEBIT The object is a surface, such as a table, desk, countertop, etc.
\end_layout

\begin_layout Itemize
Any object with the surfacebit should also have the CONTBIT (since you can
 put things on the surface) and the OPENBIT (since you can't close a countertop
 as you can a box).
\end_layout

\begin_layout Description
LOCKEDBIT Tells routines like V-OPEN that an object or door is locked and
 can't be opened without proper equipment.
\end_layout

\begin_layout Description
WEARBIT The object can be wearable, not that it is actually being worn.
\end_layout

\begin_layout Description
WORNBIT This means that a wearable object is currently being worn.
\end_layout

\begin_layout Description
READBIT The object is readable.
 Any object with a TEXT property should have the READBIT.
\end_layout

\begin_layout Description
LIGHTBIT The object is capable of being turned on and off.
 Doesn't mean that the object is actually on.
\end_layout

\begin_layout Description
ONBIT For room, it is lit.
 Outdoor rooms should have ONBIT if daytime.
 For objects, it is providing light.
 An object with the ONBIT should also have the LIGHTBIT.
\end_layout

\begin_layout Description
FLAMEBIT This means that the object is a source of fire.
\end_layout

\begin_layout Itemize
Object should also have the ONBIT and the LIGHTBIT
\end_layout

\begin_layout Description
BURNBIT The object is burnable.
\end_layout

\begin_layout Description
TRANSBIT The object is transparent; objects inside it can be seen even if
 it is closed.
\end_layout

\begin_layout Description
NDESCBIT The object shouldn't be described by the describers.
\end_layout

\begin_layout Itemize
This usually means that someone else, such as the room description, is describin
g the object.
 Any takeable object, once taken, should have its NDESCBIT cleared.
\end_layout

\begin_layout Description
INVISIBLE Tells the parser not to find this object.
 The intention is to clear the invisible at some point.
\end_layout

\begin_layout Description
TOUCHBIT For rooms, player has been to the room at least once.
 For objects, it has been taken or otherwise disturbed by the player
\end_layout

\begin_layout Itemize
Once the TOUCHBIT is set, if it has an FDESC, that FDESC will no longer
 be used
\end_layout

\begin_layout Description
SEARCHBIT Tells the parser to look as deeply into a container as it can
 in order to find the referenced object.
\end_layout

\begin_layout Itemize
Without the SEARCHBIT, the parser will only look down one level.
\end_layout

\begin_layout Itemize
Objects with a SURFACEBIT essentially function as objets with a SEARCHBIT
\end_layout

\begin_layout Description
VEHBIT This means that the object is a vehicle, and can be entered or boarded
 by the player.
\end_layout

\begin_layout Itemize
All objects with the VEHBIT should usually have the CONTBIT and the OPENBIT.
\end_layout

\begin_layout Description
PERSONBIT This means that the object is a character in the game, and such
 act accordingly.
\end_layout

\begin_layout Description
FEMALEBIT The object is an ACTOR who is a female.
\end_layout

\begin_layout Description
VOWELBIT Any verb default which prints an indefinite article before the
 DESC, use "an" instead of "a."
\end_layout

\begin_layout Description
NARTICLEBIT The object's DESC doesn't not work with articles, and they should
 be omitted.
\end_layout

\begin_layout Description
PLURALBIT The object's DESC is a plural noun or noun phrase.
 The DESC should act accordingly.
\end_layout

\begin_layout Description
RLANDBIT Usually used for rooms, llets any routine know that the room is
 dry land (as most are).
\end_layout

\begin_layout Description
RWATERBIT The room is water rather than dry land
\end_layout

\begin_layout Description
RAIRBIT The room is in mid-air, for those games with some type of flying.
\end_layout

\begin_layout Description
KLUDGEBIT This bit is used only in the syntax file.
\end_layout

\begin_layout Itemize
It is used for those syntaxes which want to be simply VERB PREPOSITION with
 no object.
 Put (FIND KLUDGEBIT) after the object.
 The parser, rather than complaining about the missing noun, will see the
 FIND KLUDGEBIT and set the PRSO (or PRSI as the case may be) to the ROOMS
 object.
\end_layout

\begin_layout Description
OUTSIDEBIT Used in rooms to classify the room as an outdoors room.
\end_layout

\begin_layout Description
INTEGRALBIT An integral part of another object, and can't be independently
 taken or dropped.
\end_layout

\begin_layout Description
PARTBIT The object is a body part: the HANDS object, for example.
\end_layout

\begin_layout Description
NALLBIT This has something to do with telling a TAKE ALL not to take something,
 but I don't recall how it works.
 Help???
\end_layout

\begin_layout Description
DROPBIT Found in vehicles, this not-very-important flag means that if the
 player drops something while in that vehicle, the object should stay in
 the vehicle rather than falling to the floor of the room itself.
\end_layout

\begin_layout Description
INBIT Another not-too-important vehicle-related flag, it tells various routines
 to say "in the vehicle" rather than "on the vehicle”.
\end_layout

\begin_layout Subsection*
Object Properties (through YZIP)
\end_layout

\begin_layout Description
NORTH,
\begin_inset space ~
\end_inset

SOUTH,
\begin_inset space ~
\end_inset

EAST,
\begin_inset space ~
\end_inset

WEST,
\begin_inset space ~
\end_inset

NE,
\begin_inset space ~
\end_inset

SE,
\begin_inset space ~
\end_inset

NW,
\begin_inset space ~
\end_inset

SW These are the direction properties, generally used only in room definitions.
\end_layout

\begin_layout Itemize
Note that the cardinal direction properties are not abbreviated, but that
 the non-cardinal ones are abbreviated.
 There is no direction property called NORTHEAST, for example.
\end_layout

\begin_layout Description
UP,
\begin_inset space ~
\end_inset

DOWN These are just like the eight direction properties.
\end_layout

\begin_layout Description
IN,
\begin_inset space ~
\end_inset

OUT These are just like the eight direction properties.
\end_layout

\begin_layout Itemize
If the player just types IN or OUT, this property will handle the movement.
 Generally, it's a good idea to give the OUT property to any room with only
 one exit.
\end_layout

\begin_layout Description
SYNONYM Contains a list of the nouns which can be used to refer to the object.
\end_layout

\begin_layout Description
ADJECTIVE Contains a list of the adjectives which can be used to refer to
 the object.
\end_layout

\begin_layout Description
ACTION Defines the action routine associated with the object.
\end_layout

\begin_layout Itemize
In the case of an object, the action routine is called when the object is
 the PRSO or the PRSI of the player's input.
 In the case of a room, the routine is called with M-BEG and MEND once each
 turn, with M-ENTER whenever the room is entered, and with MLOOK whenever
 the describers need to describe the room.
\end_layout

\begin_layout Description
DESCFCN Defines the routine which the describers use to describe the object.
\end_layout

\begin_layout Itemize
This can be the same routine as the object's action routine, provided that
 the routine is set up to handle the optional variable (M-OBJDESC or M-OBJDESC?).
\end_layout

\begin_layout Description
CONTFCN Indicates a special ROUTINE to call for objects contained in this
 object
\end_layout

\begin_layout Description
GENERIC Defines the routine which handles cases where the parser determines
 an ambiguity about which object the player is referring to.
\end_layout

\begin_layout Itemize
In the absence of a generic property, the parser will simply ask "Which
 FOO do you mean..."
\end_layout

\begin_layout Description
DESC Technically, this isn't a property, but it looks just like one when
 you define an object.
\end_layout

\begin_layout Itemize
It contains the string which, in the case of objects,will be used in verb
 defaults, player's inventory, etc.
 In the case of rooms, it is the room name which appears before room description
 and on the status line.
\end_layout

\begin_layout Description
SDESC Using this property is the only way to give an object a changable
 DESC.
\end_layout

\begin_layout Itemize
You can't <PUTP .OBJECT ,P?DESC "new desc"> but you can <PUTP .OBJECT ,P?SDESC
 "new desc">.
 Be warned, however, that if your game "shell" isn't set up for SDESCs,
 you will have to change every verb default.
 Also, be warned that doing this will increase the size of your game by
 hundreds of bytes or more, since the verb defaults will no longer simply
 TELL the desc of the object, but must instead call a little routine which
 decides whether the object in question has an SDESC or not.
\end_layout

\begin_layout Description
LDESC In the case of a room, this contains a string which the describers
 use for the long description of the room.
\end_layout

\begin_layout Itemize
In the case of an object, this contains a string which the describers use
 to describe the object if it is on the ground.
\end_layout

\begin_layout Description
FDESC This property, which isn't usually used in room definitions, contains
 a string which the describers use to describe the object before the first
 time it is moved.
\end_layout

\begin_layout Description
LOC Once again, technically not a property, but it looks just like one when
 you're creating an object.
\end_layout

\begin_layout Itemize
Simply, this property contains the name of the object which contains this
 object (in the case of a room, this is the object ROOMS).
\end_layout

\begin_layout Description
SIZE Contains a number which is the size/weight of the object.
\end_layout

\begin_layout Itemize
Generally, it is only meaningful for a takeable object.
 If a takeable object has no size property, the game usually gives it a
 default size of 5.
 The size of an object affects the number of object that a player can carry,
 how much of a container it takes up, and so on.
\end_layout

\begin_layout Description
CAPACITY Contains a number which is the capacity of the object.
\end_layout

\begin_layout Itemize
Generally, it is only meaningful for a container.
 If a container has no size property, the game usually gives it a default
 capacity of 5.
 The capacity of a container affects the number of objects which can be
 placed inside it.
\end_layout

\begin_layout Description
VALUE This property is used in many games that have scoring.
\end_layout

\begin_layout Itemize
The property contains a number; in the case of rooms, it is the number of
 points the player gets for entering the room for the first time; in the
 case of objects, it is the number of points the player gets for picking
 up the object for the first time.
\end_layout

\begin_layout Description
GLOBAL Generally found only in room definitions, this property contains
 a list of objects which are local-globals referencable in that room.
\end_layout

\begin_layout Description
OWNER Defines an object which is the owner of this object.
\end_layout

\begin_layout Itemize
For example, the SPORTS-CAR object might have the property (OWNER CYBIL)
 so that the player could refer to the car as "Cybil's car" even though
 Cybil isn't actually holding the car.
 When Cybil sells the car to the player, you would <PUTP ,SPORTS-CAR ,P?OWNER
 ,PROTAGONIST> so that the player could now refer to it as "my car."
\end_layout

\begin_layout Description
TEXT This property contains a string which is used when the player tries
 to read the object.
\end_layout

\begin_layout Itemize
It exists for those objects which would otherwise need an action routine
 to handle READ but nothing else.
\end_layout

\begin_layout Description
THINGS Formerly known as the PSEUDO property, this property allows you to
 create "pseudo-objects" with some of the properties of real objects.
\end_layout

\begin_layout Itemize
They have three parts: a list of adjectives, a list of nouns, and an action
 routine.
 Here's example: (THINGS (RED CARMINE) (SCARF ASCOT) RED-SCARF-F).
 Pseudo objects are very limited, however.
 They cannot have flags, and they cannot be moved.
 It is beneficial to use them whenever feasible, because (unlike real objects)
 they take up no pre-load space.
\end_layout

\begin_layout Description
ADJACENT Something to do with adjacent rooms and referencability.
 Stu?
\end_layout

\begin_layout Description
PLURAL Stu?
\end_layout

\begin_layout Description
PICTURE Contains the name of a graphic from the picture file associated
 with the room or object.
\end_layout

\begin_layout Description
FLAGS This is another fellow which looks just like a property but isn't
 actually a property.
\end_layout

\begin_layout Itemize
It contains a list of all the flags which are FSET in that object at the
 start of the game.
 A list of the common flags can be found in the next appendix.
 (BY the time YZIP was used, attributes were just considered a list of flags
 in this property and not a special entity).
\end_layout

\begin_layout Standard
For all exit (direction) properties, the type of exit depends on the length
 of the property:
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="60text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Unconditional Exit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 0: room number
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
No Exit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 0-1: Z-string address of exit error
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Functional Exit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
3 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 0-1: Routine address, 
\begin_inset Newline linebreak
\end_inset

Byte 2: 00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Conditional Exit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 0: Room number, 
\begin_inset Newline linebreak
\end_inset

Byte 1: Global variable, 
\begin_inset Newline linebreak
\end_inset

Byte 2-3: Z-string address for exit error
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Door Exit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
5 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Byte 0: Room number, 
\begin_inset Newline linebreak
\end_inset

Byte 1: Door object number, 
\begin_inset Newline linebreak
\end_inset

Byte 2-3: Z-string address for exit error, 
\begin_inset Newline linebreak
\end_inset

Byte 4: 00
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
ZIL-course from the Infocom Cabinet does mention two attributes and one
 property not mentioned in “Learning ZIL”:
\end_layout

\begin_layout Itemize
FURNITURE attribute: The object is a piece of furniture that a player or
 actor can sit on.
\end_layout

\begin_layout Itemize
RMUNGBIT attribute: This applies to rooms only and indicates the room does
 not exist or accessable.
 The appropriate error message needs to be given in the LDESC property.
 This is a cleaner method of removing a room.
\end_layout

\begin_layout Itemize
IN property: The container of this object
\end_layout

\begin_layout Addsec
Appendix C: Object Attributes and Properties in Zork 1
\end_layout

\begin_layout Subsection*
Attributes
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="32" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="60text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
MAZEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Room is part of the maze.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
HOUSEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Room is part of the house.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
RLANDBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Room is on dry land.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$03
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ONBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
For objects, it gives light.
 For locations, it is lit.
 All outdoor rooms should have ONBIT set.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$04
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FLAMEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be a source of fire.
 LIGHTBIT should also be set.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$05
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
VEHBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be entered or boarded by the player.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$06
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
LIGHTBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be turned on or off.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$07
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
KNIFEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can cut other objects.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$08
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
BURNBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be burned.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$09
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
READBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be read.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SURFACEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is a container and hold objects which are always visible.
 CONTBIT and OPENBIT should be set as well.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SWITCHBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be turned on or off.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TRYTAKEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
object could be picked up but other values or routines need to be checked.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
OPENBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is can be opened or closed, refers to doors and containers.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CONTBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is a container and can contain other objects or be open/closed/transparen
t.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TRANSBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is transparent so objects inside it can be found even if OPENBIT
 is clear.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$10
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FOODBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be eaten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$11
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TAKEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be picked up or carried
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ACCEPTBIT?
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
(can accept objects)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$13
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SACREDBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$14
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
PERSONBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is a character in the game.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$15
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
DOORBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is a door.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$16
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
DRINKBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be drunk.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$17
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TOOLBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be used as a tool to open other things.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$18
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CLIMBBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object can be climbed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$19
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
INTEGRALBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object cannot be taken separately from other objects, is part of another
 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
INJUREDBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is injured but not dead.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ALIVEBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is alive.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TOUCHBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
For object, it has been taken or used.
 For rooms, it has been visited.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
INVISIBLE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Object is not detected by the game.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CANTENTERBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
(or full of water bit)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
NONLANDBIT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Room is in or near the water.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Properties
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="31" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="60text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
NOT USED
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
NOT USED
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$03
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
NOT USED
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$04
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
NOT USED
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$05
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SPECIALOBJS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0-2 entries of (dict addr, paddr for DESCFCN)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$06
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
LOCAL-GLOBALS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
array of obj #s that are valid to use with object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$07
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
BITCHECK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
attribute # to check???
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$08
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TEXT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
address of z-string
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$09
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SIZE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
weight or size of the object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
CAPACITY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
maximum weight or size that on object can hold
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
FDESC
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
addr to z-string of first description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
TREASUREVALUE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
VALUE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
pts scores when taking a prized obj or entering a secret room
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
LDESC
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
addr to z-string of "lie on ground" description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$0F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
HEALTH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
0-5, 0 is healthy, 5 is dead
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$10
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ADJECTIVE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
adjective value in byte
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$11
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
ACTION
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
address to routine
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SYNONYM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
vocabulary addresses of synonymous tokens (must have default name too)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$13
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
LAND
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$14
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
OUT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$15
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
IN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$16
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
DOWN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$17
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
UP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$18
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SW
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$19
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
SE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
NW
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
NE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
S
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
W
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
$1F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
N
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
exit
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
